================================================================================
vbmodule: Konstruktoren
================================================================================
'###############################################################################
' Modul enthält Public Wrapper-Functions zum Erzeugen der PublicNotCreatable-Klassen
'Diese können nicht aus externen Modulen erzeugt werden, daher dieser Umweg
'###############################################################################
Option Explicit
'Datenbanktools
'---------------------------------------------------------------------------------------------------
Public Function New_DB_Reader() As DB_Reader
    Set New_DB_Reader = New DB_Reader
End Function
'Konstruktoren fuer KW
'------------------------------------------------------------------------
'aus Datum
Public Function New_KW_from_date(myday As Date) As Kalenderwoche
    Set New_KW_from_date = New Kalenderwoche
    New_KW_from_date.Mittwoch = myday
End Function
'aus Text
Public Function New_KW_from_text(mytext$) As Kalenderwoche
    Set New_KW_from_text = New Kalenderwoche
    New_KW_from_text.KW_txt = mytext$
End Function
'XML Tools
'---------------------------------------------------------------------------------------------------
Public Function New_XML_Toolbox() As XML_Toolbox
    Set New_XML_Toolbox = New XML_Toolbox
End Function
'Klassen fuer wallrodtsche XML
'---------------------------------------------------------------------------------------------------
Public Function New_Projekt_record() As Projekt_record
    Set New_Projekt_record = New Projekt_record
End Function
Public Function New_Pos_unterpos_records(myQM_XML_Doc As QM_XML_Doc, search$) As Pos_unterpos_records
    Set New_Pos_unterpos_records = New Pos_unterpos_records
    New_Pos_unterpos_records.init myQM_XML_Doc, search
End Function
Public Function New_QM_XML_Doc() As QM_XML_Doc
    Set New_QM_XML_Doc = New QM_XML_Doc
End Function


================================================================================
vbclass: XML_Toolbox
================================================================================
Option Explicit
'Hierdrin nur allgemeingueltige XML-Tools
'########################################################################################
Private cls_xmlDoc As DOMDocument
Private cls_xmlRoot As IXMLDOMElement
Public Property Get xmlRoot() As IXMLDOMElement
    Set xmlRoot = cls_xmlDoc.DocumentElement
End Property
Public Property Get xmldoc() As DOMDocument
    Set xmldoc = cls_xmlDoc
End Property
Public Sub open_Doc(ByVal XmlDateiMitPfad As String)
   Set cls_xmlDoc = New DOMDocument
   cls_xmlDoc.async = False
   cls_xmlDoc.validateOnParse = True                    ' Auf Fehler prüfen
   cls_xmlDoc.Load (XmlDateiMitPfad)                    ' XML-Datei laden
   If cls_xmlDoc.Load(XmlDateiMitPfad) = False Then
      MsgBox "XML-Datei: '" & XmlDateiMitPfad & "' wurde nicht gefunden"
      End
   ElseIf cls_xmlDoc.parseError = True Then
      MsgBox "XML-Datei: '" & XmlDateiMitPfad & "' hat fehlerhaften Aufbau (ist nicht 'wohlgeformt')"
      End
   End If
   cls_xmlDoc.setProperty "SelectionLanguage", "XPath"  ' Suchen soll mittels XPath erfolgen
End Sub
Public Sub create_Doc()
    Dim xmlRoot As IXMLDOMElement
   Set cls_xmlDoc = New DOMDocument
 cls_xmlDoc.appendChild        cls_xmlDoc.createProcessingInstruction("xml", "version=""1.0"" encoding=""ISO-8859-1""")
   Set cls_xmlRoot = cls_xmlDoc.createElement("root")
   cls_xmlDoc.appendChild cls_xmlRoot
End Sub
Public Sub save_Doc(file_name$)
   cls_xmlDoc.Save file_name
End Sub
'Suche einen Knoten ueber XPATH unterhalb des Knotens base_node
Public Function search_for_node(base_node As IXMLDOMElement, xpathsearch_str$) As IXMLDOMElement
   Dim xml_node As IXMLDOMElement
   Set xml_node = base_node.SelectSingleNode(xpathsearch_str)
   If xml_node Is Nothing Then
        MsgBox "Knoten <" & xpathsearch_str & "> nicht gefunden. Vermutlich falsche XML-Struktur"
        End
   Else
        Set search_for_node = xml_node
   End If
End Function
'Suche alle Knoten ueber XPATH unterhalb des Knotens base_node
Public Function search_for_nodes(base_node As IXMLDOMElement, xpathsearch_str$) As IXMLDOMNodeList
   Dim xml_nodes As IXMLDOMNodeList
   Set xml_nodes = base_node.SelectNodes(xpathsearch_str)
   If xml_nodes.Length = 0 Then
        MsgBox "Knoten <" & xpathsearch_str & "> nicht gefunden. Vermutlich falsche XML-Struktur"
        End
   Else
        Set search_for_nodes = xml_nodes
   End If
End Function


================================================================================
vbmodule: XL_Tools
================================================================================
'###############################################################################
' Modul enthält allgemeingültige, oft gebrauchte Excel-Routinen
'###############################################################################
Option Explicit
Sub Abbruchmeldung(msg$)
 MsgBox msg & vbCrLf & vbCrLf & "fehler: " & Err.Description               & vbCrLf & vbCrLf & "Programm wird abgebrochen"
    End
End Sub
'Excel oeffnen
'Pfad ohne \ am Ende
Function Oeffne_Excel(name$, Pfad$) As Workbook
    Dim uninteressant
    Set Oeffne_Excel = Nothing
    'Test ob Workbook schon offen
    On Error Resume Next
    uninteressant = Workbooks(name).FullName
    'If Workbooks(Name_Daten_Excel_File) Is Nothing Then
    If Err.Number = 9 Then
        'Noch nicht offen
        On Error GoTo 0
        Set Oeffne_Excel = Workbooks.Open(Filename:=Pfad & "\" & name)
    Else
        Set Oeffne_Excel = Workbooks(name)
    End If
    On Error GoTo 0
End Function
'Dateiauswahl
Function Waehle_Datei(Optional msg$ = "", Optional path$ = "", Optional filter$ = "") As Variant
    Dim fileToImport
    Dim old_dir$
    ' Aufforderung
    If Not msg = "" Then
        MsgBox msg
    End If
    If filter = "" Then
        filter = "Alles (*.*), *.*"
    End If
    If Not path = "" Then
        old_dir = CurDir
        ChDrive Left(path, 1)
        ChDir path
    End If
    fileToImport = Application.GetOpenFilename(filter)
    'zurückwechseln
    If Not path = "" Then
        ChDrive Left(old_dir, 1)
        ChDir old_dir
        Debug.Print CurDir
    End If
    If fileToImport = False Then
        MsgBox "Nix gewählt. Programmende"
        End
    End If
    Waehle_Datei = fileToImport
End Function
'Schreibe Header zu einer Tabelle aus CSV-String headertxt
Sub write_header(mysheet As Worksheet, start_cell, headertxt)
    Dim name
    Dim header_arr, i%
    header_arr = Split(headertxt, ";")
    i = 0
    With mysheet.Range(start_cell)
        For Each name In header_arr
            .Offset(0, i) = name
            i = i + 1
        Next
    End With
End Sub
'Zählt Zeilen einer Tabelle bei Spalte 1 von myrange
Function hole_zeilen(myrange As Range) As Long
    Dim mysheet As Worksheet
    Dim col As Long
    Set mysheet = myrange.Parent
    'Debug.Print mysheet.Name
    col = myrange.Column
    'myrange.CurrentRegion.Select
    'alt
    hole_zeilen = myrange.End(xlDown).Row
    'Neu: erst auf letzte Zeile des sheets im Range gehen => von unten suchen
    hole_zeilen = mysheet.Cells(mysheet.Rows.count, col).End(xlUp).Row
    'test ob Bereich leer, d.h. Tabellenende wird erreicht und dieses ist leer
    If hole_zeilen = mysheet.Rows.count And IsEmpty(mysheet.Cells(hole_zeilen, col)) Then
        hole_zeilen = myrange.Row
    End If
    'Sucht alle angrenzenden Zellen,nicht nur Spalte 1
    'hole_zeilen = myrange.CurrentRegion.Rows.Count
End Function
'Test ob Datei existiert
Function FileExists(ByVal File As String) As Boolean
    On Error Resume Next
    FileExists = False
    FileExists = Dir(File) <> ""
End Function


================================================================================
vbmodule: QM2XL_Tools
================================================================================
'###############################################################################
' Modul enthält Tools zum Füllen von Excel aus UNIPPS oder Quote-Master
'###############################################################################
Option Explicit


================================================================================
vbclass: Projekt_record
================================================================================
Option Explicit
Private cls_record As New record
Private cls_parent As QM_XML_Doc
Public Sub fill_from_XML_Doc(parent_QM_XML_Doc As QM_XML_Doc)
   Dim xml_Projektrecord As IXMLDOMElement
   Dim myXML_Toolbox As XML_Toolbox
   Set cls_parent = parent_QM_XML_Doc
   Set myXML_Toolbox = cls_parent.XML_Toolbox
   'Suche den Knoten "ProjektRecord" auf XML-Ebene 2
   Set xml_Projektrecord = myXML_Toolbox.search_for_node(cls_parent.xmlRoot, "/*/ProjektRecord")
   If xml_Projektrecord Is Nothing Then
        Err.Raise Number:=vbObjectError + 1, Description:="Knoten </*/ProjektRecord> nicht gefunden. Vermutlich falsche XML-Struktur"
   End If
   'Hole Daten
   cls_record.fill_from_XML_Doc xml_Projektrecord
End Sub
'testausgabe
Public Sub testprint2sheet(Optional myrange As Range)
    'record in sheet ausgeben
    cls_record.testprint2sheet "Projektdaten", myrange
End Sub
Public Function value(key$) As String
    value = cls_record.value(key$)
End Function
Public Function items() As Variant
    items = cls_record.items()
End Function
Public Function keys() As Variant
    keys = cls_record.keys()
End Function
'Public Property Get record() As record
'    Set record = cls_record
'End Property


================================================================================
vbclass: Pos_unterpos_records
================================================================================
Option Explicit
'Hole alle Daten einer Unterposition mit zugehöriger übergeordneter Position
'Unterposition(en) werden mit search$ bei "init" gesucht
'mit fill_from_XML_Doc(id%) wird immer eine Upos geladen
Private cls_UPos_record As New record
Private cls_Pos_record As New record
Private cls_pos_upos_nodes As IXMLDOMNodeList  'alle Unterknoten die gefunden wurden
Private cls_parent As QM_XML_Doc
'Suche Unterposition(en)  mit search$
Sub init(myQM_XML_Doc As QM_XML_Doc, search$)
    Dim xml_node As IXMLDOMElement
    Set cls_parent = myQM_XML_Doc
    Set cls_pos_upos_nodes = cls_parent.XML_Toolbox.search_for_nodes(cls_parent.xmlRoot, search)
End Sub
'Hole alle Datenfelder einer Unterposition (über Index id) in record-Objekt
'Sucht  zugehörige übergeordneter Position und holt ebenso in record
Public Sub make_record_current(id%)
    Dim Position As IXMLDOMElement, Unterposition As IXMLDOMElement
    'Im XML eine Ebene hoch
    Set Unterposition = cls_pos_upos_nodes(id).ParentNode
    'Lade alle daten des XML-Knotens in record-objekt
    cls_UPos_record.fill_from_XML_Doc Unterposition
    'Noch mal hoch im XML und Vorgänger holen => zugehoeriger Positionsrecord
    Set Position = Unterposition.ParentNode.PreviousSibling
    cls_Pos_record.fill_from_XML_Doc Position
End Sub
'testausgabe
Public Sub testprint_cur_record2sheet(Optional myrange As Range)
    'Position ausgeben
    cls_Pos_record.testprint2sheet "Position", myrange
    'Neue Pos im Sheet eine Zeile runter
    Set myrange = myrange.Offset(1, 0)
    'Unter-Position ausgeben
    cls_UPos_record.testprint2sheet "Unter-Position", myrange
End Sub
Public Function cur_rec_field(typ$, key$)
    If UCase(typ) = "POS" Then
        'cls_UPos_felder
        cur_rec_field = cls_Pos_record.value(key)
    ElseIf UCase(typ) = "UPOS" Then
        cur_rec_field = cls_UPos_record.value(key)
    Else
        Err.Raise Number:=vbObjectError + 2, Description:="Unzulässiger Typ <" & typ & "> in Modul Pos_unterpos_records.cur_rec_field !!"
    End If
End Function
Public Property Get pos_record() As record
   Set pos_record = cls_Pos_record
End Property
Public Property Get Upos_record() As record
    Set Upos_record = cls_UPos_record
End Property
Public Property Get node_count() As Integer
    node_count = cls_pos_upos_nodes.Length
End Property


================================================================================
vbclass: record
================================================================================
Option Explicit
'Dictionary mit allen key-value-Paaren eines QM-datensatzes für beliebige Ebenen (Projekt,Position,...)
Private cls_record As New Dictionary
'Dictionary mit allen key-value-Paaren eines XML-Knotens fuellen
'Verlässt sich auf Wallrodt-XML-Schema: Jeder Unterknoten hat genau 1 Attribut dessen Wert zum value wird, der Knoten-Name wird key
Public Sub fill_from_XML_Doc(myXMLnode As IXMLDOMElement)
    Dim my_ChildNode As IXMLDOMElement
    Set cls_record = New Dictionary
    'Für alle Kinder
    For Each my_ChildNode In myXMLnode.ChildNodes
        'Debug.Print my_ChildNode.nodeName
        If cls_record.Exists(my_ChildNode.nodeName) Then
            Application.StatusBar = "Doppelknoten: " & my_ChildNode.nodeName
        Else
            cls_record.Add my_ChildNode.nodeName, my_ChildNode.Attributes(0).NodeValue
        End If
    Next
End Sub
Public Function count() As Integer
    count = cls_record.count
End Function
Public Function items() As Variant
    items = cls_record.items()
End Function
Public Function keys() As Variant
    keys = cls_record.keys()
End Function
Public Function value(key$) As String
    If Not cls_record.Exists(key) Then
        Err.Raise Number:=vbObjectError + 2, Description:="Feld <" & key & "> nicht gefunden. Vermutlich falsche XML-Struktur"
    Else
        value = cls_record.Item(key)
    End If
End Function
Public Property Get record() As record
    Set record = cls_record
End Property
'testausgabe
Public Sub testprint2sheet(headline$, Optional myrange As Range)
    Dim i As Long
    Dim existing_sheet As Boolean
    existing_sheet = False
    If myrange Is Nothing Then
        'Neue Mappe,neues Blatt
        Set myrange = Application.Workbooks.Add.ActiveSheet.Range("a1")
        'Blatt vorbereiten
        Cells.HorizontalAlignment = xlLeft
        Cells.VerticalAlignment = xlTop
        Cells.Font.Size = 9
        Columns("A:A").ColumnWidth = 6
        Columns("C:C").ColumnWidth = 70
        existing_sheet = True
    End If
    myrange = headline
    myrange.Font.FontStyle = "Fett"
    myrange.Font.Size = 12
    For i = 1 To cls_record.count
        myrange.Offset(i, 1) = cls_record.keys(i - 1)
        myrange.Offset(i, 2) = cls_record.items(i - 1)
    Next i
    If Not existing_sheet Then
        'Blatt nachbereiten
        Columns("B:B").EntireColumn.AutoFit
        Cells.EntireRow.AutoFit
    End If
    'Pos merken und zurückgeben
    Set myrange = myrange.Offset(i, 0)
End Sub


================================================================================
vbclass: QM_XML_Doc
================================================================================
'Spezifische Funktionen, die nur im Quote-Master-Umfeld gebraucht werden / funktionieren
Private cls_xmlDoc As DOMDocument
Private cls_XML_Toolbox As New XML_Toolbox
Private cls_Projekt_record As New Projekt_record
Private cls_pump_records As New Pos_unterpos_records
'tags des dokument-records
Private cls_dok_date As Date
Private cls_dok_typ$
Private cls_dok_rev$
Private cls_dok_proj_nr$
'Einzelne XML incl Projektknoten lesen
'name = fileToOpen wenn übergeben, sonst Nutzerauswahl in default_dir (wenn übergeben)
Public Sub open_Single_Doc(Optional default_dir$ = "", Optional ByVal fileToOpen As String = "")
    Dim search$
    Dim doc_nodes As IXMLDOMNodeList  'alle Unterknoten unter Dokument
    If fileToOpen = "" Then
        fileToOpen = Waehle_Datei("XML-File waehlen", default_dir, "XML Dateien (*.xml), *.xml")
    End If
    'XML einlesen und pruefen
    cls_XML_Toolbox.open_Doc (fileToOpen)
    Set cls_xmlDoc = cls_XML_Toolbox.xmldoc
    'Erstellungsdatum
    cls_dok_date = FileDateTime(fileToOpen)
    'Dokumentdaten suchen und ablegen
    'search = "/Dokument/Erstellungsdatum"
    'cls_dok_date = get_document_tag(search)
    search = "/Dokument/Dokumententyp"
    cls_dok_typ = get_document_tag(search)
    search = "/Dokument/Projektnr."
    cls_dok_proj_nr = get_document_tag(search)
    search = "/Dokument/Revisionsindex"
    cls_dok_rev = get_document_tag(search)
    'Projektknoten im XML suchen und Daten in Objekt ablegen
    cls_Projekt_record.fill_from_XML_Doc Me
    search_pumps
End Sub
Private Function get_document_tag(tag_path$) As Variant
    'Dokument-Tags suchen und Wert liefern
    Set doc_nodes = cls_XML_Toolbox.search_for_nodes(cls_XML_Toolbox.xmlRoot, tag_path)
    get_document_tag = doc_nodes.Item(0).text
End Function
'Suche alle Unterpositionen, die Pumpen sind
Private Sub search_pumps()
    Dim search$
    search = "/*/PositionenRecords/UnterpositionenRecords/UnterpositionRecord/KnotenLevelA[@CARDINAL='1']"
    'search = "//*/KnotenLevelA[@CARDINAL='1']"
    'Suche alle Unterpositionen, die Pumpen sind
    Set cls_pump_records = New Pos_unterpos_records
    cls_pump_records.init Me, search
End Sub
Public Property Get XML_Toolbox() As Variant
    Set XML_Toolbox = cls_XML_Toolbox
End Property
Public Property Get xmlRoot() As IXMLDOMElement
    Set xmlRoot = cls_xmlDoc.DocumentElement
End Property
Public Property Get xmldoc() As DOMDocument
    Set xmldoc = cls_xmlDoc
End Property
Public Sub keys2sheet(Optional myrange As Range)
    Dim key As Variant
    Dim i%
    If myrange Is Nothing Then
        'Neue Mappe,neues Blatt
        Set myrange = Application.Workbooks.Add.ActiveSheet.Range("a1")
    End If
    myrange = "Proj"
    i = 1
    For Each key In cls_Projekt_record.keys
        myrange.Offset(i, 0) = key
        i = i + 1
    Next
    'Zuerst Einmal Daten lesen fuer Pos und Upos, sonst keys leer
    cls_pump_records.make_record_current 0
    myrange.Offset(0, 1) = "Pos"
    i = 1
    For Each key In cls_pump_records.pos_record.keys
        myrange.Offset(i, 1) = key
        i = i + 1
    Next
    myrange.Offset(0, 2) = "UPos"
    i = 1
    For Each key In cls_pump_records.Upos_record.keys
        myrange.Offset(i, 2) = key
        i = i + 1
    Next
    Cells.Font.Size = 10
    Cells.EntireRow.AutoFit
    Cells.EntireColumn.AutoFit
End Sub
Public Sub testprint2sheet(Optional myrange As Range)
    Dim i%
    cls_Projekt_record.testprint2sheet myrange
    'für alle gefundenen Pumpen:
    'Testausgabe in selbes sheet (Neue Pos im Sheet eine Zeile runter)
    Set myrange = myrange.Offset(1, 0)
    For i = 0 To cls_pump_records.node_count - 1
        'Hole Daten der Unterpos und zugehöriger Pos ins Objekt
        cls_pump_records.make_record_current i
        cls_pump_records.testprint_cur_record2sheet myrange
    Next i
End Sub
Public Property Get Projekt_record() As Projekt_record
    Set Projekt_record = cls_Projekt_record
End Property
Public Property Get pump_count() As Integer
    pump_count = cls_pump_records.node_count
End Property
Public Property Get Pump_records() As Pos_unterpos_records
    Set Pump_records = cls_pump_records
End Property
Public Function cur_rec_field(typ$, key$)
    If UCase(typ) = "PROJ" Then
        cur_rec_field = cls_Projekt_record.value(key)
    ElseIf UCase(typ) = "POS" Then
        cur_rec_field = cls_pump_records.pos_record.value(key)
    ElseIf UCase(typ) = "UPOS" Then
        cur_rec_field = cls_pump_records.Upos_record.value(key)
    Else
        Err.Raise Number:=vbObjectError + 2, Description:="Unzulässiger Typ <" & typ & "> in Modul QM_XML_Doc.cur_rec_field !!"
    End If
End Function
Public Function keys(typ$) As Variant
    If UCase(typ) = "PROJ" Then
        keys = cls_Projekt_record.keys
    ElseIf UCase(typ) = "POS" Then
        keys = cls_pump_records.pos_record.keys
    ElseIf UCase(typ) = "UPOS" Then
        keys = cls_pump_records.Upos_record.keys
    Else
        Err.Raise Number:=vbObjectError + 2, Description:="Unzulässiger Typ <" & typ & "> in Modul QM_XML_Doc.keys !!"
    End If
End Function
Public Property Get dok_date() As Date
    dok_date = cls_dok_date
End Property
Public Property Get dok_typ() As String
    dok_typ = cls_dok_typ
End Property
Public Property Get dok_rev() As String
    dok_rev = cls_dok_rev
End Property
Public Property Get dok_proj_nr() As String
    dok_proj_nr = cls_dok_proj_nr
End Property


================================================================================
vbclass: DB_Reader
================================================================================
'Functionen zum Behandeln von Excel-Tabellen oder TXT-Files als ADO-Record
'
'Die Klasse besitzt einen Recordset (locRecordset,Property rs), der von verschiedenen Routinen als Default verwendet wird.
'Diese Routinen sollten noch um einen optionalen rs Parameter erweiter werden (ToDo)
Private locAdoConnection As New ADODB.Connection
Private locRecordset As New ADODB.Recordset
'Oeffnen eines Recordsets
'###################################################################################################
Public Function open_rs_retry(sql$) As Recordset
'http://msdn.microsoft.com/en-us/library/windows/desktop/ms675544%28v=vs.85%29.aspx
    Dim myrs As New Recordset
    Dim my_err_msg$
    myrs.CursorLocation = adUseClient ' damit recordcount geht
    If locAdoConnection.State = 0 Then
        MsgBox "Keine Connection in open_rs_retry: Programmabbruch !!!"
        End
    End If
    On Error Resume Next
    open_err = 1
    Do While open_err > 0
        myrs.Open sql, locAdoConnection, adOpenStatic, adLockPessimistic ', adCmdFile
        open_err = locAdoConnection.Errors.count
        If open_err > 0 Then
            my_err_msg = Now() & " " & dbr.Connection.Errors.Item(0).Description
            Debug.Print my_err_msg
            Application.StatusBar = my_err_msg
            DoEvents
            Application.Wait (Now + TimeValue("0:00:30"))
        End If
    Loop
    Set open_rs_retry = myrs
    Debug.Print myrs.RecordCount
End Function
Public Function open_rs(sql$) As Recordset
'http://msdn.microsoft.com/en-us/library/windows/desktop/ms675544%28v=vs.85%29.aspx
    On Error Resume Next
    locRecordset.Close
    On Error GoTo Fehler
    locRecordset.CursorLocation = adUseClient ' damit recordcount geht
    locRecordset.Open sql, locAdoConnection, adOpenStatic, adLockPessimistic ', adCmdFile
    Set open_rs = locRecordset
    On Error Resume Next
    Exit Function
Fehler:
    'MsgBox "Fehler: Oeffnen Recordset" & Err.Description
    Application.StatusBar = "Fehler: Oeffnen Recordset" & Err.Description
    On Error Resume Next
End Function
Public Property Set rs(myrs As Recordset)
    Set locRecordset = myrs
End Property
Public Property Get rs() As Recordset
    Set rs = locRecordset
End Property
'###################################################################################################
'Ausführen eines SQL-Befehl ohne RS-Rueckgabe
'Gibt aber die Anzahl betroffener Datensätze zurück (z.B Insert Into Abfrage)
Public Function sql_cmd_no_output(sql$) As Long
    Dim records_aff As Long
    On Error GoTo Fehler
    locAdoConnection.Execute sql, records_aff, adCmdText + adExecuteNoRecords
    sql_cmd_no_output = records_aff
    On Error Resume Next
    Exit Function
Fehler:
    MsgBox "Fehler: " & Err.Description
    On Error Resume Next
End Function
'###################################################################################################
'Ausgabefunktionen fuer Recordsets
'Inhalt auf Sheet übertragen ohne Rücksicht auf vorhandenen Inhalt
'myrange zeigt auf linke obere Ecke der Überschrift, daten kommen 1 Zeile tiefer
'clear=true löscht Datenbereich (unter header) vorher
'header=true schreibt Feldnamen als Überschrift
Sub recordset_2_sheet(myrange As Range, Optional myrs As Recordset, Optional clear As Boolean, Optional header As Boolean)
    Dim data_rng_beg As Range
    Dim data_rng_end As Range
    On Error GoTo Fehler
    If myrs Is Nothing Then
        Set myrs = locRecordset
    End If
    If clear Then
        Set data_rng_beg = myrange.Offset(1, 0)
        Set data_rng_end = myrange.Offset(myrange.Parent.Rows.count - myrange.Row, myrs.fields.count - 1)
'        Debug.Print Range(data_rng_beg, data_rng_end).Address
        Range(data_rng_beg, data_rng_end).ClearContents
        letzte_Zeile = 1 'Daten nach Header
    Else
        letzte_Zeile = hole_zeilen(myrange) 'Sucht die letzte Zeile, die in myrange gefüllt ist
    End If
    If header Then
        header_2_sheet myrange, myrs
    End If
    myrange.Offset(letzte_Zeile, 0).CopyFromRecordset myrs
    On Error Resume Next
    Exit Sub
Fehler:
    MsgBox "Fehler: " & Err.Description
    On Error Resume Next
End Sub
'Anfügen auf Sheet mit Rücksicht auf vorhandenen Inhalt
Sub append_recordset_2_sheet(myrange As Range, Optional myrs As Recordset)
    Dim letzte_Zeile As Long
    On Error GoTo Fehler
    letzte_Zeile = hole_zeilen(myrange) 'Sucht die letzte Zeile, die in myrange gefüllt ist
    If myrs Is Nothing Then
        myrange.Offset(letzte_Zeile, 0).CopyFromRecordset locRecordset
    Else
        myrange.Offset(letzte_Zeile, 0).CopyFromRecordset myrs
    End If
    On Error Resume Next
    Exit Sub
Fehler:
    MsgBox "Fehler: " & Err.Description
    On Error Resume Next
End Sub
'Feldnamen als Header auf Sheet (nützlich wenn mit SQl "Insert Into" angefügt wird)
Public Sub header_2_sheet(myrange As Range, Optional myrs As Recordset)
    Dim i%
    On Error GoTo Fehler
    If myrs Is Nothing Then
        Set myrs = locRecordset
    End If
    For i = 0 To myrs.fields.count - 1
        myrange.Offset(0, i) = myrs.fields(i).name
    Next
    On Error Resume Next
    Exit Sub
Fehler:
    MsgBox "Fehler: " & Err.Description
    On Error Resume Next
End Sub
'Testausgabe eines rs auf debug.ausgabe
Public Sub test_output(Optional myrs As Recordset)
    Dim i%, text$
    On Error GoTo Fehler
    If myrs Is Nothing Then
        Set myrs = locRecordset
    End If
    Do Until myrs.EOF
        text = ""
        For i = 0 To myrs.fields.count - 1
            text = text & myrs.fields(i).name & ":<" & myrs.fields(i).value & ">"
        Next
        Debug.Print text
        myrs.MoveNext
    Loop
    If myrs.RecordCount > 0 Then
        myrs.MoveFirst
    End If
    On Error Resume Next
    Exit Sub
Fehler:
    MsgBox "Fehler: " & Err.Description
    On Error Resume Next
End Sub
'Zaehl- oder Summierungsabfrage ausführen. SQL muß so sein, das Ergebins im Feld "Anzahl abgelegt wird
'z.B. "Select sum(st) as Anzahl  from Import_tbl where Status2=2;"
Public Function Anzahl(sql$) As Long
    Dim myrs As ADODB.Recordset
    Set myrs = Me.open_rs(sql)
    If IsNull(myrs.fields("Anzahl")) Then
       Anzahl = 0
    Else
       Anzahl = myrs.fields("Anzahl")
    End If
End Function
'##########################################################################
'Oeffnen von Datenbanken
Public Sub Open_Informix_Connection()
    Dim sAdoConnectString As String
    sAdoConnectString = "Dsn=unipps;Driver={INFORMIX 3.30 32 BIT};"
    On Error GoTo Fehler
    locAdoConnection.Open sAdoConnectString
Aufraeumen:
    On Error Resume Next
    Exit Sub
Fehler:
    'MsgBox "Fehler beim Oeffnen der Connection: " & Err.Description
    Application.StatusBar = "Fehler beim Oeffnen der Connection: " & Err.Description
    Resume Aufraeumen
End Sub
'Oeffnen von Datenbanken
Public Sub Open_SQLite_Connection(db_path$)
    Dim sAdoConnectString As String, sPfad As String
    sAdoConnectString = "Driver=SQLite3 ODBC Driver;Database=" & db_path
    On Error GoTo Fehler
    locAdoConnection.Open sAdoConnectString
Aufraeumen:
    On Error Resume Next
    Exit Sub
Fehler:
    'MsgBox "Fehler beim Oeffnen der Connection: " & Err.Description
    Application.StatusBar = "Fehler beim Oeffnen der Connection: " & Err.Description
    Resume Aufraeumen
End Sub
Public Sub Open_Excel_Connection(path_2_workbook$)
    Dim sAdoConnectString As String
 sAdoConnectString =    "DRIVER={Microsoft Excel Driver (*.xls)};IMEX=1;ReadOnly=0;DBQ=" & path_2_workbook$
    On Error GoTo Fehler
    '?? damit recordcount geht Nebenwirkung ? locAdoConnection.CursorLocation = adUseClient
    locAdoConnection.Open sAdoConnectString
Aufraeumen:
    On Error Resume Next
    Exit Sub
Fehler:
    MsgBox "Fehler beim Oeffnen der Connection: " & Err.Description
    Resume Aufraeumen
End Sub
Sub Open_Txt_Connection(data_source_dir$)
    Dim sAdoConnectString As String, sPfad As String
 sAdoConnectString = "Provider=Microsoft.Jet.OLEDB.4.0;" & "Data Source=" & data_source_dir & ";" &          "Extended Properties=""text;HDR=YES;FMT=TABDelimited(;)"""     'HDR=NO wenn csv keine Headerzeile hat;FMT=Fixed bei festen Spalten
    On Error GoTo Fehler
    locAdoConnection.Mode = adModeReadWrite
    locAdoConnection.Open sAdoConnectString
Aufraeumen:
    On Error Resume Next
    Exit Sub
Fehler:
    MsgBox "Fehler: " & Err.Description
    Resume Aufraeumen
End Sub
Public Property Get Connection() As ADODB.Connection
    Set Connection = locAdoConnection
End Property
'##########################################################################
Private Sub Class_Terminate()
   locAdoConnection.Close
    Set locAdoConnection = Nothing
    'locRecordset.Close
End Sub
'##########################################################################
'veraltet nicht mehr benutzten
'##########################################################################
Public Function sql_cmd_with_output(sql$) As Recordset
    On Error Resume Next
    locRecordset.Close
    On Error GoTo 0
    locRecordset.CursorLocation = adUseClient ' damit recordcount geht
    locRecordset.Open sql, locAdoConnection, adOpenDynamic, adLockOptimistic ', adCmdFile
    Set sql_cmd_with_output = locRecordset
End Function
'???? Wozu Unterschiede zu txt_recordset und sql_cmd_with_output ?
Public Property Get xl_recordset(sql$) As Recordset
    On Error GoTo Fehler
    With locRecordset
        .Source = sql
        .ActiveConnection = locAdoConnection
        .Open
    End With
    Set xl_recordset = locRecordset
Aufraeumen:
    On Error Resume Next
    Exit Property
Fehler:
    MsgBox "Fehler: " & Err.Description
    Resume Aufraeumen
End Property
Public Property Get txt_recordset(sql$) As Recordset
    Const adOpenStatic = 3
    Const adLockOptimistic = 3
    Const adCmdText = &H1
    On Error GoTo Fehler
    locRecordset.Open sql, locAdoConnection, adOpenStatic, adLockOptimistic, adCmdText
    Set txt_recordset = locRecordset
    On Error Resume Next
    Exit Property
Fehler:
    MsgBox "Fehler: " & Err.Description
    On Error Resume Next
End Property


================================================================================
vbclass: Kalenderwoche
================================================================================
'!!!!!!!!!!!!!!! Fehler ?? letzte Tage am Jahresende werden zu  KW1 im nächsten Jahr
'OK wenn 1.1 in KW 1 Wenn 1.1 in KW 0 ??????
Private locWednesday As Date 'Mittwoch als Bezugstag der Woche
Private locKW% 'Zahl der Woche
'Quasi-Konstruktor der KW aus Datum:
'Mittwoch der Woche von myday als Bezugsdatum der KW setzen und Ordinalzahl der KW bestimmen und speichern
Public Property Let Mittwoch(myday As Date)
    locWednesday = Mittwoch_gleiche_Woche(myday)
    locKW = KW(locWednesday)
'    Debug.Print locWednesday, locKW
End Property
'Quasi-Konstruktor der KW aus Textwert "WW/JJJJ":
'Mittwoch der Woche von myday als Bezugsdatum der KW setzen und Ordinalzahl der KW bestimmen und speichern
Public Property Let KW_txt(myKW_txt As String)
    locWednesday = Mittwoch_der_KW(myKW_txt)
    locKW = KW(locWednesday)
'    Debug.Print locWednesday, locKW
End Property
'Berechnet zu einer KW eines Jahres in Textform ("WW/JJJJ") den Mittwoch als Datumswert
Public Function Mittwoch_der_KW(myKW_txt As String) As Date
    'Ablauf
    '1. (Neujahr des Jahres + 7*(WW -1)) ergibt einen Tag in der KW (gleicher WochenTag wie Neujahr)
    'Anzahl der Wochen immer -1 da sonst KW1 zu KW2 wird (+7 Tage) daher 7*(WW-1)
    '2. zu diesem Tag den Mittwoch der gleichen KW bestimmen
    '3. Sonderfall (z.B 1.1.2016) kurze 1. Woche zählt als KW 0 wenn sie max. 3 Tage hat, also 1.1 Fr,Sa,So
    ' dann 7 Tage mehr addieren, bzw WW=WW+1
    Dim WW%, JJJJ%, neujahr As Date
    WW = Left(myKW_txt, 2) - 1
    JJJJ = Right(myKW_txt, 4)
    'Neujahrstag des Jahres ermitteln
    neujahr = DateSerial(JJJJ, 1, 1)
    'Ist die erste angebrochene Woche ab 1.1 KW1 (ja, wenn sie mehr als 3 Tage hat)
    If Weekday(neujahr, vbMonday) >= 5 Then WW = WW + 1
    Mittwoch_der_KW = Mittwoch_gleiche_Woche(neujahr + WW * 7)
    'hier evtl checken, ob Jahr verändert wurde
End Function
'Berechnet zu einem Datum den Mittwoch der gleichen Woche
Public Function Mittwoch_gleiche_Woche(myday As Date) As Date
    'Montag ist Wochentag 1,So ist 7 (durch Weekday(myday, vbMonday))
    'Alle werden zu Wochentag 3 der selben Woche durch Addition von delta:
    ' Bei Wochentag: 1 2 3  4  5  6  7
    ' muss delta:    2 1 0 -1 -2 -3 -4   sein, also delta= 3 - Wochentag
    Mittwoch_gleiche_Woche = myday + 3 - Weekday(myday, vbMonday)
End Function
Public Property Get KW_int() As Integer
    KW_int = locKW
End Property
Public Property Get KW_txt() As String
    KW_txt = Format(locKW, "00") & "/" & Year(locWednesday)
End Property
Public Property Get Mittwoch() As Date
    Mittwoch = locWednesday
End Property
'Montag als erster Tag der KW
Public Property Get Anfang() As Date
    Anfang = locWednesday - 2
End Property
'Sonntag als letzter Tag der KW
Public Property Get Ende() As Date
    Ende = locWednesday + 4
End Property
'bestimmt ob diese KW (me) groesser als die uebergebene ist
Public Function greater(testKW$) As Boolean
    Dim testwoche$, testjahr$, aktwoche$, aktjahr$
    testwoche = Left(testKW, 2)
    testjahr = Mid(testKW, 4, 4)
    aktwoche = Format(locWednesday, "ww", vbMonday, vbFirstFourDays)
    aktjahr = Year(locWednesday)
    If aktjahr > testjahr Then
            greater = True
    ElseIf aktjahr < testjahr Then
        greater = False
    Else
        If Int(aktwoche) > Int(testwoche) Then
            greater = True
        Else
            greater = False
        End If
    End If
End Function
'bestimmt ob diese KW (me) groesser oder gleich als die uebergebene ist
Public Function greater_eq(testKW$) As Boolean
    Dim testwoche$, testjahr$, aktwoche$, aktjahr$
    testwoche = Left(testKW, 2)
    testjahr = Mid(testKW, 4, 4)
    aktwoche = Format(locWednesday, "ww", vbMonday, vbFirstFourDays)
    aktjahr = Year(locWednesday)
    If aktjahr > testjahr Then
            greater_eq = True
    ElseIf aktjahr < testjahr Then
        greater_eq = False
    Else
        If Int(aktwoche) >= Int(testwoche) Then
            greater_eq = True
        Else
            greater_eq = False
        End If
    End If
End Function
'KW um eins erhöhen (7 Tage auf Bezugsmittwoch drauf rechnen und bestimmen)
Public Function KW_plus_1_as_Text(old_KW_txt$) As String
    Dim new_KW As New Kalenderwoche
    Dim new_wednesday As Date
    new_wednesday = Mittwoch_der_KW(old_KW_txt) + 7
    new_KW.Mittwoch = new_wednesday
    KW_plus_1_as_Text = new_KW.KW_txt
End Function


================================================================================
vbmodule: Datum
================================================================================
'#########################################################################################
' Tools fuer Kalenderwochenberechnung und Datums-SQL-Formate
'#########################################################################################
'Datum in ODBC-tauglichen String fuer Excel-DB wandeln
Public Function odbc_xl_date(mydate As Date) As String
 odbc_xl_date = "{d '" & Format(Year(mydate), "0000") & "-" & Format(Month(mydate), "00") &                "-" & Format(Day(mydate), "00") & "'}"
    odbc_xl_date = "{d '" & Format(mydate, "yyyy\-mm\-dd") & "'}"
    odbc_xl_date = "'" & Format(mydate, "dd.mm.yyyy") & "'"
    odbc_xl_date = "{ts '" & Format(mydate, "yyyy\-mm\-dd 00:00:00") & "'}"
End Function
'Datum und Zeit in ODBC-tauglichen String fuer CSV-DB wandeln
Public Function odbc_csv_datetime(mydate As Date) As String
    odbc_csv_datetime = Format(mydate, "\#mm\/dd\/yyyy HH:MM:SS\#")
End Function
'Datum in ODBC-tauglichen String fuer CSV-DB wandeln
Public Function odbc_csv_date(mydate As Date) As String
    odbc_csv_date = Format(mydate, "\#mm\/dd\/yyyy\#")
End Function
' Die erste KW ist die mit 4 ganzen Tagen, also 1.1 nicht Fr,Sa,So.
Public Function KW(tag As Date) As Integer
    Dim neujahr As Date
    Dim prev_monday As Date
    Dim diff%
    'Neujahrstag des Jahres ermitteln
    neujahr = DateSerial(Year(tag), 1, 1)
    'Montag vor Neujahr
    diff = Weekday(neujahr, vbMonday) - 1
    prev_monday = neujahr - diff
    'ganze Wochen seit diesem Tag
    KW = Int((tag - prev_monday) / 7)
    'Zaehlt die erste angebrochene Woche ab 1.1 (ja wenn mehr als 3 Tage)
    If Weekday(neujahr, vbMonday) < 5 Then KW = KW + 1
End Function
Public Function KWstr(tag As Date) As String
    KWstr = Format(KW(tag), "00") & "/" & Year(tag)
End Function


================================================================================
vbmodule: UNIPPS2Excel_Tools
================================================================================
'Funktionen um UNIPPS-Daten nach Excel zu holen
'Oft benutzte Joint Klauseln
'-----------------------------------------------------------------------------------------------
' f_auftragkopf + auftragkopf + auftragpos + kunde + adresse
 Public Const f_auftragkopf = "FROM ( " & "( " & " ( " & "f_auftragkopf INNER JOIN auftragpos " & "ON f_auftragkopf.auftr_pos = auftragpos.ident_nr2 AND f_auftragkopf.auftr_nr = auftragpos.ident_nr1 " & ") " & "INNER JOIN auftragkopf ON f_auftragkopf.auftr_nr = auftragkopf.ident_nr " & ") " & "INNER JOIN kunde ON auftragkopf.kunde = kunde.ident_nr " & ") "          & "INNER JOIN adresse ON kunde.adresse = adresse.ident_nr "
' f_auftragkopf + auftragkopf + auftragpos
 Public Const f_auftragkopf_auftragkopf_auftragpos = "FROM ( " & "f_auftragkopf INNER JOIN auftragpos " & "ON f_auftragkopf.auftr_pos = auftragpos.ident_nr2 AND f_auftragkopf.auftr_nr = auftragpos.ident_nr1 " & ") " & "INNER JOIN auftragkopf ON f_auftragkopf.auftr_nr = auftragkopf.ident_nr "
' auftragkopf + auftragpos  + teil
 Public Const auftragkopf_auftragpos_teil = "FROM ( " & "auftragkopf INNER JOIN auftragpos " & "ON auftragkopf.ident_nr = auftragpos.ident_nr1 " & ") " & "INNER JOIN teil ON auftragpos.t_tg_nr = teil.ident_nr "
'Hole Kundeaufträge (nur ID'S) aus UNIPPS per Datumsfilter
'Bezeichnung beginnt mit Ersatz; Status <4
Public Function sql_ersatz_Etiketten_nur_ID(start_datum As Date)
'SELECT unipps_auftragkopf.ident_nr AS AB_Nr, unipps_auftragkopf.status, unipps_auftragpos.pos_nr, unipps_auftragpos.t_tg_nr, unipps_teil.werkstoff, unipps_teil.en_nr AS spez, unipps_teil.klassifiz AS Typ, unipps_auftragpos.k_teile_nr AS K_Ident
'FROM (unipps_auftragkopf INNER JOIN unipps_auftragpos ON unipps_auftragkopf.ident_nr = unipps_auftragpos.ident_nr1) INNER JOIN unipps_teil ON unipps_auftragpos.t_tg_nr = unipps_teil.ident_nr
'WHERE (((unipps_auftragkopf.Status) < 4) And ((unipps_auftragkopf.erstanlage) > Now() - 5) And ((unipps_auftragkopf.klassifiz) Like "Ersatz*"))
'ORDER BY unipps_auftragkopf.ident_nr, unipps_auftragpos.pos_nr;
    mysql_select = "SELECT auftragkopf.ident_nr AS AB_Nr,auftragkopf.erstanlage FROM auftragkopf "
    'datumsformat yyyy-mm-dd
    start_datum_str = odbc_xl_date(start_datum)
    'auftragpos.ueb_nr=0 da sonst untergeordnete Positionen mit uebertragen werden (erscheinen als erneute Pos 1)
 mysql_where = "WHERE auftragkopf.klassifiz like ""Ersatz%""  " & "AND auftragkopf.erstanlage >= " & start_datum_str & " " & "AND auftragkopf.status<4 "          & "ORDER BY auftragkopf.ident_nr ;"
    'Join aus Konstante oben
    sql_ersatz_Etiketten_nur_ID = mysql_select & mysql_where
End Function
'Hole einen Kundeauftrag (nur ID und anlagedatum) aus UNIPPS per ID
'Kein Filter auf Ersatz oder Status
Public Function sql_ersatz_Etiketten_nur_ID_per_ID(auftragkopf_ident_nr As Long)
    mysql_select = "SELECT auftragkopf.ident_nr AS AB_Nr,auftragkopf.erstanlage FROM auftragkopf "
 mysql_where =            "WHERE auftragkopf.ident_nr  = """ & auftragkopf_ident_nr & """  ;"
    'Join aus Konstante oben
    sql_ersatz_Etiketten_nur_ID_per_ID = mysql_select & mysql_where
End Function
'Hole einen Kundeauftrag mit relevanten Infos aus UNIPPS per ID
'Kein Filter auf Ersatz oder Status
Public Function sql_ersatz_Etiketten_per_ID(auftragkopf_ident_nr As Long)
 mysql_select = "SELECT auftragkopf.ident_nr AS AB_Nr,auftragkopf.erstanlage, auftragkopf.status, " & "auftragkopf.sprache, auftragpos.pos_nr, auftragpos.t_tg_nr, " & "teil.werkstoff, teil.en_nr AS Spezifikation, teil.klassifiz AS Typ, " & "auftragpos.k_teile_nr AS K_Ident, auftragpos.Menge, "                 & "auftragpos.k_Typ, auftragpos.k_Zchn_Nr "
    'auftragpos.ueb_nr=0 da sonst untergeordnete Positionen mit uebertragen werden (erscheinen als erneute Pos 1)
 mysql_where = "WHERE auftragkopf.ident_nr  = """ & auftragkopf_ident_nr & """  "            & "AND auftragpos.ueb_nr=0 ;"
    'Join aus Konstante oben
    sql_ersatz_Etiketten_per_ID = mysql_select & auftragkopf_auftragpos_teil & mysql_where
End Function
'Hole Kundeaufträge mit relevanten Infos aus UNIPPS per Datumsfilter
'Bezeichnung beginnt mit Ersatz; Status <4
Public Function sql_ersatz_Etiketten(start_datum As Date)
'SELECT unipps_auftragkopf.ident_nr AS AB_Nr, unipps_auftragkopf.status, unipps_auftragpos.pos_nr, unipps_auftragpos.t_tg_nr, unipps_teil.werkstoff, unipps_teil.en_nr AS spez, unipps_teil.klassifiz AS Typ, unipps_auftragpos.k_teile_nr AS K_Ident
'FROM (unipps_auftragkopf INNER JOIN unipps_auftragpos ON unipps_auftragkopf.ident_nr = unipps_auftragpos.ident_nr1) INNER JOIN unipps_teil ON unipps_auftragpos.t_tg_nr = unipps_teil.ident_nr
'WHERE (((unipps_auftragkopf.Status) < 4) And ((unipps_auftragkopf.erstanlage) > Now() - 5) And ((unipps_auftragkopf.klassifiz) Like "Ersatz*"))
'ORDER BY unipps_auftragkopf.ident_nr, unipps_auftragpos.pos_nr;
 mysql_select = "SELECT auftragkopf.ident_nr AS AB_Nr,auftragkopf.erstanlage, auftragkopf.status, " & "auftragkopf.sprache, auftragpos.pos_nr, auftragpos.t_tg_nr, " & "teil.werkstoff, teil.en_nr AS Spezifikation, teil.klassifiz AS Typ, " & "auftragpos.k_teile_nr AS K_Ident, auftragpos.Menge, "                 & "auftragpos.k_Typ, auftragpos.k_Zchn_Nr "
    'datumsformat yyyy-mm-dd
    start_datum_str = odbc_xl_date(start_datum)
    'auftragpos.ueb_nr=0 da sonst untergeordnete Positionen mit uebertragen werden (erscheinen als erneute Pos 1)
 mysql_where = "WHERE auftragkopf.klassifiz  like ""Ersatz%""  " & "AND auftragkopf.erstanlage >= " & start_datum_str & " " & "AND auftragkopf.status<4 " & "AND auftragpos.ueb_nr=0 "          & "ORDER BY auftragkopf.ident_nr, auftragpos.pos_nr ;"
    'Join aus Konstante oben
    sql_ersatz_Etiketten = mysql_select & auftragkopf_auftragpos_teil & mysql_where
End Function
Public Function sql_ersatz()
 mysql_select = "SELECT f_auftragkopf.erstanlage,f_auftragkopf.ende_ist, f_auftragkopf.ident_nr AS FA, " & "auftragkopf.klassifiz AS komm_nr, f_auftragkopf.status, f_auftragkopf.typ, " & "adresse.kurzname AS kunde, f_auftragkopf.auftr_nr AS KA, auftragpos.pos_nr AS Pos, " & "auftragpos.lt, f_auftragkopf.losgroesse_soll AS stueck, f_auftragkopf.t_soll, """                           & Now() & """ As eingelesen "
 mysql_where = "WHERE f_auftragkopf.oa=1 " & "AND auftragkopf.klassifiz  like ""Ersatz%""  " & "AND f_auftragkopf.status<7 "          & "ORDER BY auftragpos.lt ;"
    sql_ersatz = mysql_select & f_auftragkopf & mysql_where
End Function
Public Function sql_offene_Pumpen()
 mysql_select = "SELECT f_auftragkopf.erstanlage,f_auftragkopf.ende_ist, f_auftragkopf.ident_nr AS FA, " & "auftragkopf.klassifiz AS komm_nr, f_auftragkopf.status, f_auftragkopf.typ, " & "adresse.kurzname AS kunde, f_auftragkopf.auftr_nr AS KA, auftragpos.pos_nr AS Pos, " & "auftragpos.lt, f_auftragkopf.losgroesse_soll AS stueck, f_auftragkopf.t_soll/0.3 as MA, "                           & "auftragkopf.letzte_aenderung,auftragkopf.von, """ & Now() & """ As eingelesen "
 mysql_where = "WHERE f_auftragkopf.oa=0 " & "AND auftragkopf.klassifiz like ""__.%""  " & "AND f_auftragkopf.status<7 "          & "ORDER BY f_auftragkopf.erstanlage desc;"
    sql_offene_Pumpen = mysql_select & f_auftragkopf & mysql_where
End Function
Public Function sql_offen_und_fgm_seit_datum(start_datum As Date)
 mysql_select = "SELECT f_auftragkopf.erstanlage,f_auftragkopf.ende_ist, f_auftragkopf.ident_nr AS FA, " & "auftragkopf.klassifiz AS komm_nr, f_auftragkopf.status, f_auftragkopf.typ, " & "adresse.kurzname AS kunde, f_auftragkopf.auftr_nr AS KA, auftragpos.pos_nr AS Pos, " & "auftragpos.lt, f_auftragkopf.losgroesse_soll AS stueck, f_auftragkopf.t_soll/0.3 as MA, """                           & Now() & """ As eingelesen "
    'datumsformat yyyy-mm-dd
    start_datum_str = odbc_xl_date(start_datum)
 mysql_where = "WHERE f_auftragkopf.oa=0 " & "AND auftragkopf.klassifiz like ""__.%""  " & "AND f_auftragkopf.status<8 " & "AND (f_auftragkopf.ende_ist>=" & start_datum_str & " OR f_auftragkopf.ende_ist< {d ""1900-01-01""}) "          & "ORDER BY f_auftragkopf.ende_ist;"
    sql_offen_und_fgm_seit_datum = mysql_select & f_auftragkopf & mysql_where
End Function
Public Function sql_offen_und_fgm_nach_Lieferkw_seit_Lieferkw(start_datum As Date)
 mysql_select = "SELECT f_auftragkopf.erstanlage,f_auftragkopf.ende_ist, f_auftragkopf.ident_nr AS FA, " & "auftragkopf.klassifiz AS komm_nr, f_auftragkopf.status, f_auftragkopf.typ, " & "adresse.kurzname AS kunde, f_auftragkopf.auftr_nr AS KA, auftragpos.pos_nr AS Pos, " & "auftragpos.lt, f_auftragkopf.losgroesse_soll AS stueck, f_auftragkopf.t_soll/0.3 as MA, """                           & Now() & """ As eingelesen "
    'datumsformat yyyy-mm-dd
    start_datum_str = odbc_xl_date(start_datum)
 mysql_where = "WHERE f_auftragkopf.oa=0 " & "AND auftragkopf.klassifiz like ""__.%""  " & "AND f_auftragkopf.status<8 " & "AND auftragpos.lt>=" & start_datum_str          & " ORDER BY auftragpos.lt;"
    sql_offen_und_fgm_nach_Lieferkw_seit_Lieferkw = mysql_select & f_auftragkopf & mysql_where
End Function
Public Function sql_reparatur()
 mysql_select = "SELECT f_auftragkopf.erstanlage,f_auftragkopf.ende_ist, f_auftragkopf.ident_nr AS FA, " & "auftragkopf.klassifiz AS komm_nr, f_auftragkopf.status, f_auftragkopf.typ, " & "adresse.kurzname AS kunde, f_auftragkopf.auftr_nr AS KA, auftragpos.pos_nr AS Pos, " & "auftragpos.lt, f_auftragkopf.losgroesse_soll AS stueck, f_auftragkopf.t_soll, "                           & "auftragkopf.letzte_aenderung,auftragkopf.von, """ & Now() & """ As eingelesen "
 mysql_where = "WHERE f_auftragkopf.oa=0 " & "AND auftragkopf.klassifiz not like ""__.%""  " & "AND f_auftragkopf.status<7 "          & "ORDER BY f_auftragkopf.erstanlage desc;"
    sql_reparatur = mysql_select & f_auftragkopf & mysql_where
End Function
Public Function sql_ersatz_kumuliert()
 mysql_select = "SELECT auftragpos.lt, ' ' as LT_KW, sum(f_auftragkopf.losgroesse_soll) AS stueck, "                           & "sum(f_auftragkopf.t_soll*24) as FA_h "
 mysql_where = "WHERE f_auftragkopf.oa=1 " & "AND auftragkopf.klassifiz  like ""Ersatz%""  " & "AND f_auftragkopf.status<7 "          & "group BY auftragpos.lt order BY auftragpos.lt;"
    sql_ersatz_kumuliert = mysql_select & f_auftragkopf_auftragkopf_auftragpos & mysql_where
End Function
'Pumpen_KA/FA seit erstanlagedatum KA_status >0
' auftragkopf.klassifiz Like "__.%"
'neue Version mit FA-Termin statt KA-Termin
'und Filter: f_auftragkopf.t_tg_nr not like "P%" (ohne Prüpfstandsaufträge)
Public Function sql_pumpen_FA(start_datum As Date) As String
    Dim start_datum_str$, sql_select$
    start_datum_str = odbc_xl_date(start_datum)
    'start_datum_str = "'" & start_datum & "'"
 sql_select = "SELECT """ & Now() & """ As eingelesen, " & "auftragkopf.klassifiz AS komm_nr, adresse.kurzname AS kunde, " & "auftragkopf.ident_nr as KA,auftragkopf.status as KA_status, auftragpos.pos_nr AS KA_Pos," & "f_auftragkopf.ident_nr AS FA, f_auftragkopf.status as FA_status," & " auftragkopf.erstanlage as UNIPPS_erstanlage,f_auftragkopf.typ,f_auftragkopf.losgroesse_soll AS stueck, " & "f_auftragkopf.ende_soll as lt, '' as LT_KW,f_auftragkopf.t_soll/0.3 as MA, "                           & " auftragkopf.letzte_aenderung, auftragkopf.faktura_datum, auftragkopf.storno_datum "
 sql_where = " WHERE f_auftragkopf.oa=0 and auftragkopf.klassifiz Like ""__.%"" And auftragkopf.Status > 0" & " And auftragkopf.klassifiz not like ""0-%""" & " And f_auftragkopf.t_tg_nr not like ""P%""" & " And auftragkopf.erstanlage > " & start_datum_str                & " ORDER BY auftragkopf.ident_nr,auftragpos.pos_nr  ;"
    sql_pumpen_FA = sql_select & f_auftragkopf & sql_where
End Function
'Pumpen_KA seit erstanlagedatum KA_status >0
'alte Version mit KA-Termin
Public Function sql_pumpen_KA(start_datum As Date)
    Dim start_datum_str$, sql_select$
    start_datum_str = odbc_xl_date(start_datum)
    'start_datum_str = "'" & start_datum & "'"
 sql_select = "SELECT """ & Now() & """ As eingelesen, " & "auftragkopf.klassifiz AS komm_nr, adresse.kurzname AS kunde, " & "auftragkopf.ident_nr as KA,auftragkopf.status as KA_status, auftragpos.pos_nr AS KA_Pos," & "f_auftragkopf.ident_nr AS FA, f_auftragkopf.status as FA_status," & " auftragkopf.erstanlage as UNIPPS_erstanlage,f_auftragkopf.typ,f_auftragkopf.losgroesse_soll AS stueck, " & "auftragpos.lt, '' as LT_KW,f_auftragkopf.t_soll/0.3 as MA, "                           & " auftragkopf.letzte_aenderung, auftragkopf.faktura_datum, auftragkopf.storno_datum "
 sql_where = " WHERE f_auftragkopf.oa=0 and auftragkopf.klassifiz Like ""__.%"" And auftragkopf.Status > 0" & " And auftragkopf.erstanlage > " & start_datum_str                & " ORDER BY f_auftragkopf.ident_nr ;"
    sql_pumpen_KA = sql_select & f_auftragkopf & sql_where
End Function
'fakturierte oder stornierte pumpen_KA seit datum
Public Function sql_pumpen_KA_fgm(start_datum As Date)
    Dim start_datum_str$, sql_select$
    start_datum_str = odbc_xl_date(start_datum)
 sql_select = "SELECT auftragkopf.ident_nr, auftragkopf.klassifiz, auftragkopf.erstanlage, auftragkopf.status, " & " auftragkopf.letzte_aenderung, auftragkopf.faktura_datum, auftragkopf.storno_datum "                        & " FROM auftragkopf "
 sql_where = " WHERE auftragkopf.klassifiz Like ""__.%"" And auftragkopf.Status > 4" & " And (auftragkopf.faktura_datum > " & start_datum_str & "      OR auftragkopf.storno_datum > " & start_datum_str & ")"                & " ORDER BY auftragkopf.erstanlage;"
    sql_pumpen_KA_fgm = sql_select & sql_where
End Function
'Daten mit sql-befehl "sql$" aus UNIPPS in "Tabelle$"  lesen
Function UNIPPS_Import(sql$, target_rng As Range) As Long
    Dim dbr As DB_Reader
    Dim rs As ADODB.Recordset
    Dim open_err%
    'Datenbank verbinden
    Set dbr = New_DB_Reader()
    dbr.Open_Informix_Connection
    Set dbr.rs = dbr.open_rs(sql)
    open_err = dbr.Connection.Errors.count
    'dbr.test_output
    'If dbr.rs.RecordCount > 0 And open_err = 0 Then
    If open_err = 0 Then
        'Application.StatusBar = "Daten gelesen"
        dbr.recordset_2_sheet target_rng, dbr.rs, clear:=True, header:=True
        UNIPPS_Import = dbr.rs.RecordCount
    Else
        Application.StatusBar = "Abbruch mit Fehler: " & dbr.Connection.Errors.Item(0).Description
        Dim msg$
        msg = dbr.Connection.Errors.Item(0)
        Set dbr = Nothing
        UNIPPS_Import = -1
        Err.Raise 10000, "UNIPPS_Import", msg
    End If
    Set dbr.rs = Nothing
End Function
'Import in "Tabelle$" nachbearbeiten: KW in Spalte "spalte" aus linker Nachbarspalte berechnen
Sub get_KW(myrange As Range)
    Dim line As Long
    line = 1
    Do While Not IsEmpty(myrange.Offset(line, -1))
        myrange.Offset(line, 0) = "'" & KWstr(myrange.Offset(line, -1))   'LT_KW aus LT
        line = line + 1
    Loop
End Sub


<EndofFile>