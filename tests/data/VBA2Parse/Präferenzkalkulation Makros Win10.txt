================================================================================
vb_office_obj: DieseArbeitsmappe
================================================================================


================================================================================
vbmodule: Globals
================================================================================
'Hier stehen Daten von globaler Bedeutung:
     'Namen und Objekte von Excel-Mappen und Blättern
     'Überschriften für die Ausgabe
     'Objekte zum Zugriff auf die Datenbank
'Sie müssen vor jedem Funktionsaufruf mit der Funktion set_globals gesetzt werden
Option Explicit
Public Const mit_csv_export = False
'Mappen und Blattnamen
Public Const xls_codemappe = "Präferenzkalkulation Makros.xlsm"
Public xls_hauptmappe$
Public Const import_sheet_name = "import"   'sheet fuer UNIPPS Import
Public Const preis_sheet_name = "Listenpr"  'sheet Eingabe  der Listenpreis der Kundenauftragspostionen
Public Const stu_sheet_name = "Kalkulation"   'sheet fuer Kurzfassung der Stückliste
Public Const rs_debug_sheet_name = "rs_debug"   'sheet fuer testausgaben von abfragen
Public data_wb As Workbook  'Arbeitsmappe mit Daten
Public code_wb As Workbook  'Mappe mit Software
Public imp_sheet As Worksheet  'sheet fuer UNIPPS Import
Public stu_sheet As Worksheet  'sheet fuer Kurzfassung der Stückliste
Public preis_sheet As Worksheet  'sheet Eingabe  der Listenpreis der Kundenauftragspostionen
Public rs_debug_sheet As Worksheet  'sheet fuer testausgaben von abfragen
'Überschriften und Konstanten f Ausgabe
 Public Const full_header = "Ebene,Typ,zu Teil,FA,id_pos,ueb_s_nr,ds,pos_nr,verurs_art,t_tg_nr,oa,Bezchng,typ,v_besch_art,urspr_land,ausl_u_land,praeferenzkennung," & "menge,sme,faktlme_sme,lme," & "bestell_id,bestell_datum,preis,basis,pme,bme,faktlme_bme,faktbme_pme,id_lief,"                         & "lieferant,pos_menge,preis_eu,preis_n_eu,Summe_Eu,Summe_n_EU,LP je Stück,KT_zu_LP"
 Public Const KA_doku_header = "Ebene,t_tg_nr,Bezeichnung,"                         & "Menge,Lieferant,Preis_eu,Preis_n_eu,Summe_Eu,Summe_n_EU,LP(Stück),KT_zu_LP,Präfb."
Public Const KA_doku_header_min_col = 1
'Public Const KA_doku_header_med_col = 9    'Mittelspalte ohne Hinterlegung
Public Const KA_doku_header_max_col = 12
Public Const Preis_header = "id_pos,Menge,t_tg_nr,Bezeichnung,VK brutto je Stück,Rabatt,VK netto je Stück,Subpos zu"
'Sonstige Globals
'###########################################
'Datenbank-Reader
Public UNIPPS_dbr As DB_Reader
Public SQLite_dbr As DB_Reader
'Klasse zum Ausführen von SQL-Abfragen
Public SQL_exec As SQL_Executor
'Liste von Endknoten (Blätter des Baumes, noch ohne Kinder und auch nicht Kaufteil)
'wird fuer stufenweise Suche verwendet
Public teile_ohne_stu As Collection
'Modul zur Ausgabe von Meldungen
Public Logger As Logger_cls
'Vorbelegung von globalen Variablen
Public Sub set_globals()
    'Mappe und Blatt fuer Import
    Set data_wb = Workbooks(xls_hauptmappe)
    Set code_wb = Workbooks(xls_hauptmappe)
    Set imp_sheet = data_wb.Worksheets(import_sheet_name)
    Set preis_sheet = data_wb.Worksheets(preis_sheet_name)
    Set rs_debug_sheet = code_wb.Worksheets(rs_debug_sheet_name)
    Set stu_sheet = data_wb.Worksheets(stu_sheet_name)
    'Globalen Datenbankreader anlegen und Verbindung herstellen
    Set UNIPPS_dbr = New_DB_Reader
    UNIPPS_dbr.Open_Informix_Connection
    'Globales Objekt zur SQL-Ausführung anlegen
    Set SQL_exec = New SQL_Executor
End Sub
'Legt einen Logger an und setzt dessen Batch-Modus
'Bei True erfolgen die Ausgaben nur in eine Datei und nicht per Msxbox
Public Sub set_logger(Optional batchmode As Boolean = False)
    Set Logger = New Logger_cls
    Logger.init batchmode
End Sub


================================================================================
vbmodule: main
================================================================================
'In diesem Modul stehen die Funktionen, die direkt aufgerufen werden.
'Sie bilden die oberste Programmebene
Option Explicit
'Die folgenden Funktionen sind Buttons in der Hauptmappe zugeordnet
'Sie dienen hauptsächlich zum Einlesen der ID des Kundeauftrages
'Die Arbeit wird von den weiter unten stehenden Funktionen erledigt, die schon eine ID als Parameter erwarten
Public Sub Btn_hole_Preise_fuer_KA_Positionen()
    Dim ka$
    xls_hauptmappe = Application.ActiveWorkbook.Name
    set_logger
    ka = Application.ActiveSheet.Range("D5")
    hole_KA_Positionen_fuer_Preisblatt (ka)
End Sub
Public Sub Btn_KA_Analyse()
    Dim ka$
    xls_hauptmappe = Application.ActiveWorkbook.Name
    set_logger
    ka = Application.ActiveSheet.Range("D5")
    start_KA_Analyse (ka)
End Sub
'Druckt das Dokumentationsblatt aus
Public Sub Btn_print_doku()
    Dim ka$
    xls_hauptmappe = Application.ActiveWorkbook.Name
    set_globals
    set_logger
    ka = Application.ActiveSheet.Range("D5")
    'Erzeugt Text-Datei mit allen präferenz-berechtigten Teilen
    store_eu_non_eu_parts ka, berechtigte:=True
    'Erzeugt Text-Datei mit allen nicht präferenz-berechtigten Teilen
    store_eu_non_eu_parts ka, berechtigte:=False
    'Zeige Ergebnis als Excel-Druckvorschau
    stu_sheet.PrintPreview
End Sub
'Speichert das Dokumentationsblatt als PDF und erzeugt Textfile mit allen nicht EU-Toplevel-Positionen
Public Sub Btn_speichere_pdf()
    Dim ka$
    Dim berechtigte As Boolean
    xls_hauptmappe = Application.ActiveWorkbook.Name
    set_logger
    ka = Application.ActiveSheet.Range("D5")
    'Erzeugt Text-Datei mit allen präferenz-berechtigten Teilen
    store_eu_non_eu_parts ka, berechtigte:=True
    'Erzeugt Text-Datei mit allen nicht präferenz-berechtigten Teilen
    store_eu_non_eu_parts ka, berechtigte:=False
    'Speichere Ergebnis als PDF
    store_pdf (ka)
End Sub
'Schreibt wichtige Daten des Kundenauftrages auf das Blatt zur Eingabe der Listenpreise
Public Sub hole_KA_Positionen_fuer_Preisblatt(ka_id$)
    Dim myKA As Kundenauftrag
    Dim ka_pos As Kundenauftrags_Position
    Dim myrow As Long
    set_globals
    'Blatt leeren
    Preis_sheet_reset
    'Daten lesen
    Set myKA = New Kundenauftrag
    myKA.init ka_id
    'Daten ausgeben
    myrow = 2
    For Each ka_pos In myKA.stueli
        ka_pos.write2Excel_Preisblatt myrow
        myrow = myrow + 1
    Next
    'Blatt aktivieren (anzeigen)
    preis_sheet.Activate
End Sub
'Liest alle Daten des Kundeauftrages rekursiv bis zur untersten Ebene
'Gibt die Daten in Excel aus
Public Sub start_KA_Analyse(ka_id$)
    Dim myKA As Kundenauftrag
    Dim Baum_komplett As STU_Baum
    Dim Baum_doku As STU_Baum
    Dim Start As Double
    Start = Timer
    Application.ScreenUpdating = False
    Logger.log CStr(Application.ScreenUpdating)
    Application.StatusBar = "lese Daten"
    set_globals
    'Ausgabe-Blätter leeren
    import_sheet_reset
    KA_doku_sheet_reset
    'Objekt anlegen und Positionen des KA einlesen
    Set myKA = New Kundenauftrag
    myKA.init ka_id
    'Lese Verkaufpreise aus Excel
    'Dies ist nötig, wenn in UNIPPS keine Preise waren und diese manuell ergänzt wurden
    myKA.hole_Listenpreise
    'Kinder der Positionen des KA einlesen
    'Aufbau der kompletten Struktur
    myKA.hole_Kinder
    'Falls es Positionen des KA gibt, die eigentlich Unterpositionen anderer Pos. sind:
    'Beispiel Motor gehört zu Pumpenaggregat
    myKA.sortiere_neu
    'Umwandeln in Baumstruktur mit typunabhängigen (allgemeinen) Knoten
    'Berechnen der Preissummen
    Set Baum_komplett = New STU_Baum
    myKA.erzeuge_Baum Baum_komplett, mit_FA:=True
    'volle Ausgabe zum debuggen
    Baum_komplett.write2Excel_debug
    'Ausgabe zum Drucken (auch pdf) und aufheben
    Set Baum_doku = New STU_Baum
    myKA.erzeuge_Baum Baum_doku, mit_FA:=False
    Baum_doku.write2Excel_KA_doku
    Application.StatusBar = "fertig"
    Logger.user_info "Fertig analysiert nach " & Format(Timer - Start, "#0.00") & " Sekunden.", level:=1
End Sub
'Erzeugt Text-Dateien mit allen präferenz-berechtigten bzw nicht präferenz-berechtigten Teilen
Public Sub store_eu_non_eu_parts(ka_id$, berechtigte As Boolean)
    Dim fso As FileSystemObject
    Dim outfile As TextStream
    Dim pfad$, file_name$
    Dim myrow As Long
    Dim teilenr$, pfk$, itemname$
    Dim i%
    set_globals
    pfad = data_wb.Path 'PDF ins Verzeichnis der Excel-Mappe
    If berechtigte Then
        file_name = pfad & "\" & "berechtigt_" & ka_id$ & ".txt"
    Else
        file_name = pfad & "\" & ka_id$ & "_nicht_berechtigt.txt"
    End If
    Set fso = New FileSystemObject
    Set outfile = fso.CreateTextFile(file_name)
    '2 Durchgänge für deutsche und englische Ausgabe
    For i = 1 To 2
        If i = 1 Then
            itemname = "- item: "
        Else
            itemname = "- Ident-Nr.: "
        End If
        myrow = 7
        teilenr = stu_sheet.Cells(myrow, 2)
        Do While teilenr <> ""
            pfk = stu_sheet.Cells(myrow, 12)
            'Gebe nur berechtigte Teile aus
            If berechtigte = True And pfk = "j" Then
                outfile.WriteLine itemname & teilenr
            End If
            'Gebe nur nicht berechtigte Teile aus
            If berechtigte = False And pfk = "n" Then
                outfile.WriteLine itemname & teilenr
            End If
            myrow = myrow + 1
            teilenr = stu_sheet.Cells(myrow, 2)
        Loop
        outfile.WriteLine
    Next
    outfile.Close
End Sub
'Erzeugt PDF aus Dokumentationsblatt
Public Sub store_pdf(ka_id$, Optional zeigen As Boolean = True)
    Dim pfad$, pdf_name$
    set_globals
    pfad = data_wb.Path 'PDF ins Verzeichnis der Excel-Mappe
    'pdf_name = pfad & "\pdf\" & ka_id$
    'pfad = "V:\Versand\Ermaechtigter Ausfuehrer" 'PDF ins Verzeichnis der Excel-Mappe
    pdf_name = pfad & "\" & ka_id$ & ".pdf"
 stu_sheet.ExportAsFixedFormat Type:=xlTypePDF, filename:=pdf_name, Quality:=xlQualityStandard, IncludeDocProperties:=True, IgnorePrintAreas        :=False, OpenAfterPublish:=True
End Sub


================================================================================
vbmodule: nach_Excel
================================================================================
'In diesem Modul stehen Hilfsfunktionen zum Schreiben von Daten in Excel-Tabellen
Option Explicit
'Setze das Sheet für die Debug-Ausgabe in den Basiszustand
Public Sub import_sheet_reset()
    'Inhalte loeschen
    imp_sheet.Cells.ClearContents
    'Ueberschriften schreiben
    write_debug_header
End Sub
'Setze das Sheet für die Listenpreiseingabe in den Basiszustand
Public Sub Preis_sheet_reset()
    'Inhalte loeschen
    preis_sheet.Cells.ClearContents
    'Ueberschriften schreiben
    write_header preis_sheet, 1, Preis_header
End Sub
'Setze das Sheet für die KA-Doku in den Basiszustand
'die ersten 5 Zeilen bleiben unberührt
Public Sub KA_doku_sheet_reset()
    'Inhalte loeschen
    stu_sheet.Range("A6:BA1000000").ClearContents
    'Schattierung raus
    DeColorCells stu_sheet
    'Ueberschriften schreiben
    write_KA_doku_header
End Sub
'Schreibt die Header Liste fuer die Tabelle mit den debug-Daten
Public Sub write_debug_header()
    write_header imp_sheet, 1, full_header
End Sub
'Schreibt die Header Liste fuer die Doku eines KA
Public Sub write_KA_doku_header()
    write_header stu_sheet, 6, KA_doku_header
    ColorCells stu_sheet, 6, KA_doku_header_min_col, KA_doku_header_max_col, "grau_1"
End Sub
'Schreibt Elemente einer Liste (z.B. Überschriften) in die Zeile row eines Blattes
Public Sub write_header(target_sheet As Worksheet, row As Long, header_liste)
    Dim col%
    Dim namen
    namen = Split(header_liste, ",")
    For col = 0 To UBound(namen)
        target_sheet.Cells(row, col + 1) = namen(col)
    Next
End Sub
'Entfernt Hintergrundfarbe aus allen Zellen eines Blattes
Public Sub DeColorCells(target_sheet As Worksheet)
    target_sheet.Cells.Interior.TintAndShade = 0
    target_sheet.Cells.Interior.Pattern = xlNone
End Sub
'Entfernt Hintergrundfarbe aus einer Spalte eines Blattes
Public Sub DeColorColumn(target_sheet As Worksheet, mycol%)
    target_sheet.Columns(mycol).Interior.TintAndShade = 0
    target_sheet.Columns(mycol).Interior.Pattern = xlNone
End Sub
'Setzt Hintergrundfarbe für eine Zeile  eines Blattes in den Spalten col_min% bis  col_max%
Public Sub ColorCells(target_sheet As Worksheet, row As Long, col_min%, col_max%, farbe$)
    'grau hinterlegen
    Dim my_int As Interior
    Dim old_sheet As Worksheet
    Set old_sheet = Excel.ActiveSheet
    target_sheet.Activate
    'Geht nur wenn sheet aktiv ?????
    Set my_int = target_sheet.Range(Cells(row, col_min), Cells(row, col_max)).Interior
    my_int.Pattern = xlSolid
    Select Case farbe
        Case "grau_1":
            my_int.TintAndShade = -0.3
        Case "grau_2":
            my_int.TintAndShade = -0.15
        Case "rot":
            my_int.TintAndShade = -0.15
            my_int.Color = 5263615
        Case "":
            my_int.TintAndShade = 0
            my_int.Pattern = xlNone
    End Select
    old_sheet.Activate
End Sub
'Ermittelt aus einem Hierarchie-level einen schön formatierten String mit Punkten am Anfang
Public Function level_formatiert(level)
    Dim i%
    For i = 1 To level
        level_formatiert = level_formatiert & "."
    Next i
    level_formatiert = level_formatiert + Str(level)
End Function


================================================================================
vbclass: Bestellung
================================================================================
Option Explicit
Public bestell_id
Public bestell_datum
Public pme_preis As Double
Public basis
Public pme
Public bme
Public faktlme_bme
Public faktbme_pme
Public netto_poswert
Public menge
Public we_menge
Public lieferant
Public kurzname
Public existiert As Boolean 'Gibt es Bestelldaten
Private Preis_je_LME As Double 'Preis je Lagermengeeinheit
Public last_col% 'letzte Spalte, in welche in Excel geschrieben wurde
Private rs As Recordset
Public Sub init(t_tg_nr$)
    Dim max_preis As Double
    Dim record_id_max_preis As Long
    existiert = SQL_exec.suche_letzte_3_Bestellungen(t_tg_nr, rs)
    'Suche max Preis aus 3 Bestellungen
    max_preis = 0
    Do While Not rs.EOF
        Preis_je_LME = Berechne_Preis_je_LME_rabattiert()
        If Preis_je_LME > max_preis Then
            'id merken
            max_preis = Preis_je_LME
            record_id_max_preis = rs.AbsolutePosition
        End If
        rs.MoveNext
    Loop
    If existiert Then
        'Positioniere auf Datensatz mit max Preis
        rs.MoveFirst
        rs.Move record_id_max_preis - 1
        'Weitere Bestelldaten in Eigenschaften wandeln
        bestell_id = rs.Fields("bestell_id")
        bestell_datum = rs.Fields("bestell_datum")
        pme_preis = rs.Fields("preis") 'Preis bezogen auf basis und preismengeneinheit
        basis = rs.Fields("basis")
        pme = rs.Fields("pme")
        bme = rs.Fields("bme")
        faktlme_bme = rs.Fields("faktlme_bme")
        faktbme_pme = rs.Fields("faktbme_pme")
        netto_poswert = rs.Fields("netto_poswert")
        menge = rs.Fields("menge")
        we_menge = rs.Fields("we_menge")
        lieferant = rs.Fields("lieferant")
        kurzname = Trim(rs.Fields("kurzname"))
        'Es gibt eine Bestellung zur t_tg_nr => Netto-Preis je Liefermengeneinheit berechnen und merken
        Preis_je_LME = Berechne_Preis_je_LME_rabattiert()
    Else
        'Es gibt keine Bestellung zu t_tg_nr$
        Preis_je_LME = 0
    End If
End Sub
Private Function Berechne_Preis_je_LME_rabattiert() As Double
    's. auch Erklärungen in Berechne_Preis_je_LME_unrabattiert
    Dim preis As Double
    Dim br_preis As Double
    Dim brutto_pos_wert As Double
    'Debug.Print rs.Fields("bestell_id")
    'Wert der Bestellpos ohne Rabatte:
    'wert = Preis_je_BME * Bestellmenge
    '=> analog
    'Wert der Bestellpos mit Rabatt:
    'wert = rs.Fields("netto_poswert") = Preis_je_BME_netto = rs.Fields("netto_poswert") * Bestellmenge
    'also: Preis_je_BME_netto = rs.Fields("netto_poswert") / * Bestellmenge
    preis = rs.Fields("netto_poswert") / rs.Fields("menge")
    'Kontrolle ob Werkzeugpreise einflossen
    '-----------------------------------------------
   'unrabbatierter Preis je Preismengeneinheit
    br_preis = rs.Fields("preis") / rs.Fields("basis")
    'Preis je Bestellmengeneinheit
    br_preis = br_preis * rs.Fields("faktbme_pme")
    brutto_pos_wert = br_preis * rs.Fields("menge")
    If rs.Fields("netto_poswert") > 2 * brutto_pos_wert Then
        'Hier stimmt was nicht. Netto-Wert viel größer als Brutto
        'Wir nehmen Brutto
        preis = br_preis
        Dim msg$
        msg = "In Bestellung: " & CStr(rs.Fields("bestell_id")) & " ist der Nettopreis höher als der Bruttopreis. "
        msg = msg & vbCrLf & "Evtl wurde Werkzeugkosten verrechnet." & vbCrLf & "Es wird mit dem Bruttopreis gerechnet. "
        Logger.user_info msg
    End If
    'Preis je Lagermengeneinheit
    Berechne_Preis_je_LME_rabattiert = preis * rs.Fields("faktlme_bme")
    'Probe
'    If Abs(rs.Fields("netto_poswert") - rs.Fields("menge") * preis) > 0.01 Then
'        Logger.user_info "Evtl Fehlerhafte Preisberechnung in Bestellung: " & CStr(rs.Fields("bestell_id"))
'    End If
End Function
Private Function Berechne_Preis_je_LME_unrabattiert() As Double
    Dim preis As Double
    'Daten in UNIPPS aus Bestllung/Zusatz/Zusatzdaten zur Bestellposition (im Feld Preis) bzw Hauptformular zum Teil
    'Beispiel ERMPEØ40
    'Basis=1
    'PME=kg (Preismengeneinheit)
    'BME=Stück (Bestellmengeneinheit)
    'faktbme_pme= 2,48 Kg/St;   wieviele PME ergeben eine BME ? 2,48 Kg ergeben 1 Stück
    'Preis_je_PME=8,35€/Kg aus Bestellung
    'Preis_je_BME = Preis_je_PME *faktbme_pme=8,35€/Kg * 2,48Kg/St = 20,71€/St
    'LME=m (Lagermengeeinheit)
    'faktlme_bme=0,5St/m;  wieviele BME ergeben eine LME ? 0,5 ergeben 1 Stück
    'Preis_je_LME = Preis_je_BME * faktlme_bme = 20,71€/St * 0,5St/m = 10,35 €/m
    'UNIPPS-Feld Preis ist Preis je Basis (UNIPPS-Feld Basis) und Preismengeneinheit PME
    'unrabbatierter Preis je Preismengeneinheit
    preis = rs.Fields("preis") / rs.Fields("basis")
    'Preis je Bestellmengeneinheit
    preis = preis * rs.Fields("faktbme_pme")
    'Preis je Lagermengeneinheit
    Berechne_Preis_je_LME_unrabattiert = preis * rs.Fields("faktlme_bme")
End Function
'Gesamt-Preis einer Stücklistenposition aus Menge und Preis je Lagermengeeinheit berechnen
Public Function STU_Pos_Preis(menge As Double, faktlme_sme As Double) As Double
    'Beipiel
    'SME=mm
    'LME=m
    'Preis je Liefermengeneinheit=10,35 €/m
    'faktlme_sme=1000 [mm/m];   wieviele SME ergeben eine LME ? 1000 mm ergeben 1 m
    'Preis je Stücklistenmengeneinheit ist Preis je Lagermengeeinheit "Preis_je_LME" geteilt durch faktlme_sme
    'Preis_je_SME also 10,35 €/m (Preis_je_LME) / (1000 mm/m) = 0,01035 €/mm
    STU_Pos_Preis = Preis_je_LME / faktlme_sme
    'Preis der Stücklistenposition durch Mult. mit der übergeordneten gesamten Menge
    STU_Pos_Preis = STU_Pos_Preis * menge
End Function
Public Sub write2Excel_debug(myrow As Long, start_col%)
    'Einige Daten in Standard-Import-Blatt schreiben
    Dim col%
    col = start_col
    col = col + 1: imp_sheet.Cells(myrow, col) = bestell_id
    col = col + 1: imp_sheet.Cells(myrow, col) = bestell_datum
    col = col + 1: imp_sheet.Cells(myrow, col) = pme_preis
    col = col + 1: imp_sheet.Cells(myrow, col) = basis
    col = col + 1: imp_sheet.Cells(myrow, col) = pme
    col = col + 1: imp_sheet.Cells(myrow, col) = bme
    col = col + 1: imp_sheet.Cells(myrow, col) = faktlme_bme
    col = col + 1: imp_sheet.Cells(myrow, col) = faktbme_pme
    'col = col + 1: imp_sheet.Cells(myrow, col) = netto_poswert
    col = col + 1: imp_sheet.Cells(myrow, col) = lieferant
    col = col + 1: imp_sheet.Cells(myrow, col) = kurzname
    last_col = col
End Sub


================================================================================
vbclass: Kundenauftrag
================================================================================
Option Explicit
Public ka_id$
Public kunden_id$
Public komm_nr$
Public stueli As Collection 'Stueckliste
'Liste aller Zuordnungen von Positionen zu übergeordnetetn Positionen mit id_pos als Index
'zu_pos(3)=1 bedeutet also: Die Pos mit der id_pos=3 ist Unterposition der Pos mit id_pos=1
Public zu_Pos As Dictionary
Public Sub init(id$)
    Dim rs As Recordset, rs_rabatt As Recordset
    Dim gefunden As Boolean
    Dim ka_pos As Kundenauftrags_Position
    Dim stu_pos As STUELI_Position
    Dim rabatt As Double
    Set stueli = New Collection
    Set zu_Pos = New Dictionary
    'id als Eigenschaft merken
    ka_id = id
    'Suche Positionen im Kundenauftrag der id KA_id
    'Abfrage mit globalem Objekt ausführen und  recordset merken
    gefunden = SQL_exec.suche_Kundenauftragspositionen(ka_id, rs)
    'Wenn Daten gefunden
    If gefunden Then
        komm_nr = rs.Fields("klassifiz")
        kunden_id = rs.Fields("kunde")
    Else
        Logger.user_info "Konnte keine Daten zu " & ka_id & " finden.", level:=1
    End If
    'Suche Positionen im Kundenauftrag der id KA_id
    'Abfrage mit globalem Objekt ausführen und  recordset merken
    SQL_exec.hole_Rabatt_zum_Kunden kunden_id, rs_rabatt
    If rs_rabatt.RecordCount > 1 Then
        Logger.user_info "Es wurden " & rs_rabatt.RecordCount & " Rabatte zum Kunden " & kunden_id & " des Auftrages gefunden."
    ElseIf rs_rabatt.RecordCount = 1 Then
        rabatt = rs_rabatt.Fields("zu_ab_proz") / 100
    End If
    'Daten analysieren
    Do While Not rs.EOF
        'Erzeuge eine KA-Position aus dem Datensatz
        Set ka_pos = New Kundenauftrags_Position
        ka_pos.init rs.Fields, rabatt
        If InStr(ka_pos.t_tg_nr, "PP") <> 1 And InStr(ka_pos.t_tg_nr, "PK") <> 1 Then
            'in Stueck-Liste übernehmen
            stueli.Add ka_pos, CStr(ka_pos.id_pos)
        End If
        rs.MoveNext
    Loop
End Sub
Public Sub sortiere_neu()
    Dim super_pos$, sub_pos$
    Dim super_part, sub_part
    Dim i%
    For i = 0 To zu_Pos.Count - 1
        super_pos = zu_Pos.Items(i)
        sub_pos = zu_Pos.Keys(i)
        Debug.Print sub_pos & " gehört zu " & super_pos
        Set super_part = stueli.Item(CStr(super_pos))
        Set sub_part = stueli.Item(CStr(sub_pos))
        '!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        'Achtung: passt das immer ?
        sub_part.menge = 1
        'Untergeordnete Pos an Stueckliste der uebergeordneten anhaengen
        super_part.stueli.Add sub_part
        'VK des untergeordneten Teils zum uebergeordneten addieren
        super_part.vk_rabatt = super_part.vk_rabatt + sub_part.vk_rabatt
        sub_part.vk_rabatt = 0
        'Untergeordnete Pos aus aktuelles Stueckliste loeschen
        stueli.Remove CStr(sub_pos)
    Next i
End Sub
Public Sub hole_Listenpreise()
    Dim ka_pos As Kundenauftrags_Position
    Dim Preise As Dictionary 'Liste aller Preis mit id_pos als Index
    Dim row%
    Dim id_pos%
    Dim super_pos%
    Dim preis As Double
    'Zuerst Preise aus Excel lesen
    Set Preise = New Dictionary
    row = 2
    Do While preis_sheet.Cells(row, 1) <> ""
        id_pos = preis_sheet.Cells(row, 1)
        preis = preis_sheet.Cells(row, 7)
        super_pos = preis_sheet.Cells(row, 8)
        Preise.Add Key:=CStr(id_pos), Item:=preis
        If super_pos <> 0 Then
            zu_Pos.Add Key:=CStr(id_pos), Item:=super_pos
        End If
        row = row + 1
    Loop
    For Each ka_pos In stueli
        'If ka_pos.vk_preis = 0 Then
            If Preise.Exists(ka_pos.id_pos) Then
                ka_pos.vk_rabatt = Preise(CStr(ka_pos.id_pos))
            Else
                Logger.user_info "Konnte keinen Preis zu Pos-Nr " & ka_pos.id_pos & " in Excel Tabelle " & preis_sheet_name & " finden.", level:=2
                If Not Logger.batch_modus Then
                    MsgBox "Programmabbruch", vbCritical
                    End
                End If
            End If
        'End If
    Next
End Sub
Public Sub hole_Kinder()
    Dim ka_pos As Kundenauftrags_Position
    Dim pos As Variant
    Dim teile_ohne_stu_aktuell As Collection
    Set teile_ohne_stu = New Collection
    Set teile_ohne_stu_aktuell = New Collection
    'Schritt 1 nur über Kommissions-FA suchen. Diese haben Prio 1.
    'Fuer alle Pos, die kein Kaufteil sind, rekursiv in der UNIPPS-Tabelle ASTUELIPOS nach Kindern suchen
    'Alle Kinder, die in ASTUELIPOS selbst keine Kinder mehr haben werden in der Liste teile_ohne_stu vermerkt
    For Each ka_pos In stueli
        Application.StatusBar = "erzeuge Strukturbaum für KA-Pos " & ka_pos.id_pos
        If Not ka_pos.teile_daten.ist_Kaufteil Then
            ka_pos.hole_Kinder_aus_Komm_FA
        End If
    Next
    'Suche Kinder für die Knoten der Liste teile_ohne_stu bis diese leer ist.
    Do
        'Original-Liste leeren (vorher kopieren)
        Set teile_ohne_stu_aktuell = teile_ohne_stu
        Set teile_ohne_stu = New Collection
        'Fuer alle Teile der Liste
        For Each pos In teile_ohne_stu_aktuell
            'Suche Kinder, Knoten die nicht Kaufteil sind in teile_ohne_stu merken
             suche_Kinder_v_Serien_Teil pos
        Next
    Loop Until teile_ohne_stu.Count = 0
End Sub
'Umwandeln der typspezifischen Objekte in Baumstruktur mit typunabhängigen (allgemeinen) Knoten
Public Sub erzeuge_Baum(Baum As STU_Baum, mit_FA As Boolean)
    Dim level%
    Dim menge_ueb As Double 'multiplizierte Menge aller übergeordneten Positionen (im KA immer 1)
    Dim ka_pos As Kundenauftrags_Position
    Dim stueli_pos As STUELI_Position
    'level immer 0 da Kundenauftrag
    level = 0
    'menge übergeordent immer 1 da Kundenauftrag
    menge_ueb = 1
    Baum.init
    For Each ka_pos In stueli
        'Erzeuge neuen, typunabhängigen Stueli-Eintrag
        Set stueli_pos = New STUELI_Position
        stueli_pos.init ka_pos, level, menge_ueb
        'In Baum.stueli uebernehmen
        Baum.stueli.Add stueli_pos
        'Suche alle Unterpositionen von ka_pos und trage sie in die stueli von stueli_pos ein
        Baum.erzeuge_Baum ka_pos, stueli_pos, mit_FA
    Next
    'Fuer jede Pos im Baum Preise aller Unterpos aufsummieren
    Baum.summiere_Preise
End Sub


================================================================================
vbclass: SQL_Executor
================================================================================
Option Explicit
'SQL-Abfrage sucht Fertigungsauftrag zu einer Position im Kundenauftrag
Public Function suche_FA_zu_KAPos(id_stu$, id_pos$, rs As Recordset) As Boolean
    Dim sql$
    'siehe Access Abfrage "a_FA_Kopf_zu_KAPos_mit_Teileinfo"
    'Suche über f_auftragkopf.auftr_nr=KA_id (Id des Kundenauftrages) und f_auftragkopf.auftr_pos=pos_id
 sql = "SELECT f_auftragkopf.auftr_nr as id_stu, " & "f_auftragkopf.auftr_pos as pos_nr, f_auftragkopf.auftragsart, f_auftragkopf.verurs_art, f_auftragkopf.t_tg_nr, f_auftragkopf.oa, " & "f_auftragkopf.typ,  " & "f_auftragkopf.ident_nr as id_FA " & "FROM f_auftragkopf " & "Where f_auftragkopf.auftr_nr=" & id_stu & " and f_auftragkopf.auftr_pos=" & id_pos & " and f_auftragkopf.oa<9 "        & " ORDER BY id_FA;"
    'Abfrage ausführen und recordset zurück liefern
    Set rs = hole_recordset(sql)
    suche_FA_zu_KAPos = rs.RecordCount > 0
    'csv_out rs, "FA_zu_KAPos"
End Function
'SQL-Abfrage Suche einen Serien-FA zu einem Teil
'Es wird der neueste FA verwendet (höchste ID)
Public Function suche_FA_zu_Teil(t_tg_nr$, rs As Recordset) As Boolean
    Dim sql$
    'siehe Access Abfrage "b_suche_FA_zu_Teil"
 sql = "SELECT first 1 f_auftragkopf.auftr_nr as id_stu,  " & "f_auftragkopf.auftr_pos as pos_nr, f_auftragkopf.auftragsart, f_auftragkopf.verurs_art, f_auftragkopf.t_tg_nr, f_auftragkopf.oa, " & "f_auftragkopf.typ, f_auftragkopf.ident_nr as id_FA " & "FROM f_auftragkopf " & "Where f_auftragkopf.t_tg_nr=""" & t_tg_nr & """ and f_auftragkopf.oa<9 "        & " ORDER BY id_FA desc;"
    'Abfrage ausführen und recordset zurück liefern
    Set rs = hole_recordset(sql)
    suche_FA_zu_Teil = rs.RecordCount > 0
    'csv_out rs, "FA_zu_Teil"
End Function
'SQL-Abfrage Suche eine Stückliste zum Teil
Public Function suche_Stueli_zu_Teil(t_tg_nr$, rs As Recordset) As Boolean
    Dim sql$
    'siehe Access Abfrage "b_suche_Stueli_zu_Teil"
    'Suche über teil_stuelipos.ident_nr1=t_tg_nr
    'Es werden die Daten aus teil_stuelipos gelesen
    'Es existieren z.T. unterschiedlich Stücklisten wegen mehrerer Arbeitspläne (Ausweichmaschine mit anderen Rohteilen)
    'Es wird daher zu TEIL_APLNKOPF gejoined und dort teil_aplnkopf.art=1 gefordert (Standardarbeitsplan)
 sql = "SELECT teil_stuelipos.ident_nr1 As id_stu, teil_stuelipos.pos_nr, teil_stuelipos.t_tg_nr, teil_stuelipos.oa, teil_stuelipos.menge " & "FROM teil_aplnkopf INNER JOIN teil_stuelipos ON teil_aplnkopf.ident_nr1 = teil_stuelipos.ident_nr1 " & "AND teil_aplnkopf.ident_nr2 = teil_stuelipos.ident_nr2 AND teil_aplnkopf.ident_nr3 = teil_stuelipos.ident_nr3 " & "WHERE teil_stuelipos.ident_nr1=""" & t_tg_nr & """ And teil_aplnkopf.art=""1"" "        & "ORDER BY teil_stuelipos.pos_nr ;"
    'Abfrage ausführen und recordset zurück liefern
    Set rs = hole_recordset(sql)
    suche_Stueli_zu_Teil = rs.RecordCount > 0
    'csv_out rs, "Stueli_zu_Teil"
End Function
'SQL-Abfrage holt Kundenauftrag und seine Positionen
Public Function suche_Kundenauftragspositionen(ka_id$, rs As Recordset) As Boolean
    Dim sql$
    '(siehe Access Abfrage "b_hole_KAPositionen")
 sql = "SELECT auftragpos.ident_nr1 as id_stu, auftragpos.ident_nr2 as id_pos, auftragkopf.kunde, auftragpos.besch_art, auftragkopf.klassifiz, auftragpos.pos as pos_nr, " & "auftragpos.t_tg_nr, auftragpos.oa, auftragpos.typ, auftragpos.menge, auftragpos.preis " & "FROM auftragkopf INNER JOIN auftragpos ON auftragkopf.ident_nr = auftragpos.ident_nr1 "        & "WHERE auftragpos.ueb_nr=0 and auftragpos.ident_nr1 = """ & ka_id & """ "
    'Abfrage ausführen und recordset zurück liefern
    Set rs = hole_recordset(sql)
    suche_Kundenauftragspositionen = rs.RecordCount > 0
    'csv_out rs, "Kundenauftragspositionen"
End Function
'SQL-Abfrage holt Rabatt zu einem Kunden
Public Function hole_Rabatt_zum_Kunden(kunden_id$, rs As Recordset) As Boolean
    Dim sql$, heute_datum_str$
    'datumsformat yyyy-mm-dd
    heute_datum_str = odbc_xl_date(Now())
    '(siehe Access Abfrage "b_hole_Rabatt_zum_Kunden")
 sql = "SELECT ident_nr1 as kunden_id, zu_ab_proz, datum_von, datum_bis " & "FROM kunde_zuab " & "WHERE ident_nr1 = """ & kunden_id & """ AND datum_von<=" & heute_datum_str                 & " AND datum_bis>" & heute_datum_str & " ; "
    'Abfrage ausführen und recordset zurück liefern
    Set rs = hole_recordset(sql)
    hole_Rabatt_zum_Kunden = rs.RecordCount > 0
    'csv_out rs, "Rabatt"
    'sqlite_out rs, "Rabatt"
End Function
'Suche alle Positionen zu einem FA (ASTUELIPOS)
Public Function hole_Pos_zu_FA(FA_id$, rs As Recordset) As Boolean
    Dim sql$
    'siehe Access Abfrage "b_hole_Pos_zu_FA"
    'Suche über astuelipos.ident_nr1=FA_id (Id des Fertigungsauftrages)
 sql = "SELECT astuelipos.ident_nr1 AS id_stu, astuelipos.ident_nr2 as id_pos, " & "astuelipos.ueb_s_nr, astuelipos.ds, astuelipos.set_block, " & "astuelipos.pos_nr, astuelipos.t_tg_nr, astuelipos.oa, " & "astuelipos.typ, astuelipos.menge " & "FROM astuelipos " & "WHERE astuelipos.ident_nr1=" & FA_id & " AND astuelipos.oa<9 AND astuelipos.ds<9 "          & "ORDER BY astuelipos.ident_nr2"
 sql = "SELECT astuelipos.ident_nr1 AS id_stu, astuelipos.ident_nr2 as id_pos, " & "astuelipos.ueb_s_nr, astuelipos.ds, astuelipos.set_block, " & "astuelipos.pos_nr, astuelipos.t_tg_nr, astuelipos.oa, " & """ ""as typ, astuelipos.menge " & "FROM astuelipos " & "WHERE astuelipos.ident_nr1=" & FA_id & " AND astuelipos.oa<9 AND astuelipos.ds<9 "          & "ORDER BY astuelipos.ident_nr2"
    'Abfrage ausführen und recordset zurück liefern
    Set rs = hole_recordset(sql)
    hole_Pos_zu_FA = rs.RecordCount > 0
    'UNIPPS_dbr.recordset_2_sheet rs_debug_sheet.Range("A1"), rs, True, True
    'csv_out rs, "Pos_zu_FA"
End Function
'SQL-Abfrage holt Zusatzinformationen zu einem Teil aus den Tabellen "TEIL" und "TEIL_UW"
Public Function suche_Daten_zum_Teil(t_tg_nr$, rs As Recordset) As Boolean
    Dim sql$
    '(siehe Access Abfrage "b_hole_Daten_zu Teil")
 sql = "SELECT teil_uw.t_tg_nr, teil_uw.oa, " & "teil_uw.v_besch_art as besch_art, teil.typ, teil.urspr_land, teil.ausl_u_land, teil.praeferenzkennung, " & "teil.sme, teil.faktlme_sme, teil.lme " & "FROM teil INNER JOIN teil_uw ON teil.ident_nr = teil_uw.t_tg_nr AND teil.art = teil_uw.oa " & "Where teil_uw.t_tg_nr=""" & t_tg_nr        & """ and teil_uw.oa<9 AND teil_uw.uw=1; "
 sql = "SELECT teil_uw.t_tg_nr, teil_uw.oa, " & "teil_uw.v_besch_art as besch_art, "" "" as typ, teil.urspr_land, teil.ausl_u_land, teil.praeferenzkennung, " & "teil.sme, teil.faktlme_sme, teil.lme " & "FROM teil INNER JOIN teil_uw ON teil.ident_nr = teil_uw.t_tg_nr AND teil.art = teil_uw.oa " & "Where teil_uw.t_tg_nr=""" & t_tg_nr        & """ and teil_uw.oa<9 AND teil_uw.uw=1; "
    'Abfrage ausführen und recordset zurück liefern
    Set rs = hole_recordset(sql)
    suche_Daten_zum_Teil = rs.RecordCount > 0
    'csv_out rs, "Daten_zum_Teil"
End Function
'SQL-Abfrage sucht letzte 3 Bestellungen zu einem Teil
Public Function suche_letzte_3_Bestellungen(t_tg_nr$, rs As Recordset) As Boolean
    Dim sql$, sql_sub$
    'siehe Access Abfrage "b_Bestelldaten"
    'Suche über unipps_bestellpos.t_tg_nr=t_tg_nr; bestellkopf.datum muss aus der Unterabfrage hervorgehen (neuestes Datum)
 sql = "SELECT first 3 bestellkopf.ident_nr as bestell_id, bestellkopf.datum as bestell_datum, bestellpos.preis, bestellpos.basis, bestellpos.pme, bestellpos.bme, " & "bestellpos.faktlme_bme, bestellpos.faktbme_pme, bestellpos.netto_poswert, bestellpos.menge, bestellpos.we_menge, " & "bestellkopf.lieferant, adresse.kurzname, bestellpos.t_tg_nr " & "FROM bestellpos INNER JOIN bestellkopf ON bestellpos.ident_nr1 = bestellkopf.ident_nr " & "JOIN adresse ON bestellkopf.lieferant = adresse.ident_nr "        & "WHERE bestellpos.t_tg_nr=""" & t_tg_nr$ & """ order by bestellkopf.datum desc ;"
    'Abfrage ausführen und recordset zurück liefern
    Set rs = hole_recordset(sql)
    suche_letzte_3_Bestellungen = rs.RecordCount > 0
    'csv_out rs, "letzte_3_Bestellungen"
End Function
'Sucht Bezeichnung zu einem Teil
Public Function hole_Teile_Bezeichnung(t_tg_nr$, rs As Recordset) As Boolean
    'siehe Access Abfrage "b_hole_Teile_Bezeichnung"
    Dim sql$
 sql = "SELECT teil_bez.ident_nr1 AS teil_bez_id, teil_bez.Text AS Bezeichnung FROM teil_bez "                              & "WHERE ident_nr1=""" & t_tg_nr$ & """ and teil_bez.sprache=""D"" AND teil_bez.art=1 ;"
    'Abfrage ausführen und recordset zurück liefern
    Set rs = hole_recordset(sql)
    hole_Teile_Bezeichnung = rs.RecordCount > 0
    'csv_out rs, "Teile_Bezeichnung"
End Function
'########################### helper #############################
'Allgemeingueltige Funktion fuer SQL-Abfragen
Public Function hole_recordset(sql$) As Recordset
    'UNIPPS_dbr ist global und verbunden
    'Oeffne recordset
    Set hole_recordset = UNIPPS_dbr.hole_recordset(sql)
    'Fehlerhandling
    If UNIPPS_dbr.Connection.Errors.Count <> 0 Then
        Debug.Print sql
        Debug.Print UNIPPS_dbr.Connection.Errors(0).Description
        abbruchmeldung "UNIPPS-Daten konnten nicht gelesen werden."
    End If
    'Set hole_recordset = UNIPPS_dbr.rs
End Function


================================================================================
vbclass: Kundenauftrags_Position
================================================================================
Option Explicit
'Eigenschaften fuer alle Eintraege
Public pos_typ$
Public id_stu$ 'Id der Stückliste zu der die Position gehört
Public t_tg_nr$ 'Teilenummer des Teils auf der KA-Position
Public pos_nr$
Public menge As Double
Public teile_daten As Teiledaten 'Daten zum Teil auf der Position
Public stueli As Collection 'VBA-Stueckliste dieser Position
'Besondere Eigenschaften fuer diesen Typ
Public id_pos$  'Id der Stücklisten-Position
Public vk_preis As Double 'Verkaufspreis vor Rabatt für 1 Stück
Public vk_rabatt As Double 'Verkaufspreis nach Rabatt für 1 Stück
Public rabatt As Double 'Rabatt Achtung Vorzeichen ist negativ
Public unipps_typ$
Public komm_nr$
Public Sub init(record As Fields, my_rabatt As Double)
    Dim rs As Recordset
    Dim gefunden As Boolean
    pos_typ = "KA_Pos"
    Set stueli = New Collection
    id_pos = record("id_pos")
    id_stu = record("id_stu")
    pos_nr = Trim(record("pos_nr"))
    t_tg_nr = Trim(record("t_tg_nr"))
    unipps_typ = Trim(record("typ"))
    menge = Trim(record("menge"))
    'Ermittle den Listenpreis aus UNIPPS
    vk_preis = Trim(record("preis"))
    rabatt = my_rabatt
    vk_rabatt = vk_preis * (1 + rabatt) 'Rabbat hat -
    komm_nr = record("klassifiz")
    'Suche Teil zu dieser Pos
    gefunden = SQL_exec.suche_Daten_zum_Teil(t_tg_nr, rs)
    If gefunden Then
        Set teile_daten = New Teiledaten
        teile_daten.init rs.Fields
    Else
        Logger.user_info "Konnte kein Teil >>" & t_tg_nr & "<< finden.", level:=2
    End If
End Sub
'Sucht Kinder zu einer Position im Kundenauftrag
'Die Position kann a) komm-spezifisch sein oder b) ein Teil mit Serienfertigung oder c) ein Kaufteil
'Fuer a) wird ein FA-Objekt erzeugt und als Zwischenebene in die Stückliste eingetragen
Public Sub hole_Kinder_aus_Komm_FA()
    Dim myFA As FA
    Dim rs As Recordset
    Dim gefunden As Boolean
    'Gibt es auftragsbezogene FAs zur Pos im Kundenauftrag
    gefunden = SQL_exec.suche_FA_zu_KAPos(id_stu, id_pos, rs)
    Do While Not rs.EOF
        'Erzeuge Objekt fuer einen auftragsbezogenen FA
        Set myFA = New FA
        myFA.init rs.Fields
        'in Stueck-Liste übernehmen
        stueli.Add myFA
        'Kinder suchen
        myFA.hole_Kinder
        'Naechter Datensatz
        rs.MoveNext
    Loop
    'Keine Kinder im auftragsbezogenen FA
    '=> Teil fuer spaetere Suche merken
    If Not gefunden And Not teile_daten.ist_Kaufteil Then
        teile_ohne_stu.Add Me
    End If
End Sub
Public Sub write2Excel_Preisblatt(myrow As Long)
    Dim col%
    col = 0
    col = col + 1: preis_sheet.Cells(myrow, col) = Me.id_pos
    col = col + 1: preis_sheet.Cells(myrow, col) = Me.menge
    col = col + 1: preis_sheet.Cells(myrow, col) = Me.t_tg_nr
    col = col + 1: preis_sheet.Cells(myrow, col) = Me.teile_daten.bezeichnung
    col = col + 1: preis_sheet.Cells(myrow, col) = Me.vk_preis
    col = col + 1: preis_sheet.Cells(myrow, col) = Me.rabatt
    col = col + 1: preis_sheet.Cells(myrow, col) = Me.vk_rabatt
End Sub


================================================================================
vbclass: STUELI_Position
================================================================================
'Die Klasse enthält die Stücklistenelemente in verallgemeinerter Form
'Dies vereinfacht das Durchlaufen durch den Baum, das alle Elemente (fast) gleich behandelt werden können
'Sie enthalten alle zur Ausgabe bzw Berechnung nötigen Daten
'und zusätzlich als Pos_daten die spezifischen Original-Elemente aus Kundenauftrag,Teil_in_STU usw
'außerdem als "teile_daten" die Daten des Teils zur Position
Option Explicit
Public level% 'Ebene auf der das Teil im Gesamtbaum steht
Public menge_ueb As Double 'Aufmultiplizierte Menge aller übergeordneten Stücklisteneinträge
Public Pos_daten As Variant 'Objekt, welches die typ-spezifischen Daten hält
'Felder aus Pos_daten
Public pos_typ$
Public id_stu$
Public id_pos$
Public ueb_s_nr$
Public ds$
Public pos_nr$
Public verurs_art$
Public menge As Double
Public vk_preis As Double 'Verkaufspreis vor Rabatt für 1 Stück
Public vk_rabatt As Double 'Verkaufspreis nach Rabatt für 1 Stück
Public rabatt As Double 'Rabatt Achtung Vorzeichen ist negativ
Public FA_Nr$
Public komm_nr$
Public teile_daten As Teiledaten
Public stueli As Collection 'VBA-Stueckliste dieser Position
'Preise
'mit Stückzahlen und Mengenfaktoren auf die Position umgerechnet
Public preis_EU As Double
Public preis_Non_EU As Double
'Summen
Public Summe_EU As Double
Public Summe_Non_EU As Double
Public Sub init(meine_Pos, act_level%, act_menge_ueb As Double)
    Set stueli = New Collection
    Set Pos_daten = meine_Pos
    pos_typ = Pos_daten.pos_typ
    id_stu = Pos_daten.id_stu
    pos_nr = Pos_daten.pos_nr
    id_pos = ""
    vk_preis = 0
    vk_rabatt = 0
    rabatt = 0
    FA_Nr = ""
    komm_nr = ""
    verurs_art = ""
    menge = Pos_daten.menge
    If pos_typ = "KA_Pos" Then
        vk_preis = Pos_daten.vk_preis
        vk_rabatt = Pos_daten.vk_rabatt
        rabatt = Pos_daten.rabatt
        komm_nr = Pos_daten.komm_nr
        id_pos = Pos_daten.id_pos
    End If
    If pos_typ = "FA_Komm" Or pos_typ = "FA_Serie" Then
        FA_Nr = Pos_daten.FA_Nr
        verurs_art = CStr(Pos_daten.verurs_art)
    End If
    If pos_typ = "FA_Pos" Then
        ueb_s_nr = Pos_daten.ueb_s_nr
        ds = Pos_daten.ds
        id_pos = Pos_daten.id_pos
    End If
    Set teile_daten = Pos_daten.teile_daten
    level = act_level
    menge_ueb = act_menge_ueb * Pos_daten.menge
End Sub
'rechnet den Einzelpreis aus der Bestellung mit Gesamtmenge
'und dem  Faktor faktlme_sme (Stücklistenmengeneinheit zu Lagermengeneinheit)
'um auf den Preis der konkreten Stücklistenposition
Public Sub berechne_Preis_der_Position()
    Dim preis As Double
    Dim stupos As STUELI_Position
    If teile_daten.hat_Preis Then
        preis = teile_daten.Bestelldaten.STU_Pos_Preis(menge_ueb, teile_daten.faktlme_sme)
        If teile_daten.praeferenzkennung = 1 Then
            preis_EU = preis
        Else
            preis_Non_EU = preis
        End If
    Else
        preis_EU = 0
        preis_Non_EU = 0
    End If
    'Kinder bearbeiten
    For Each stupos In stueli
        stupos.berechne_Preis_der_Position
    Next
End Sub
'Summiere Preise für ein Teil
' aus der Summe der Kosten aller Teile in seiner Stueckliste
' und einem evtl zusätzlich vorhandenen eigenen Preis
'Beispiel Laufraeder: wir kaufen 233I26543PERF03 bei Ottenstein
'in der Stueckliste ist aber die Gewindebuchse 544D26265NKM019, die wir auch kaufen
'Der Gesatmpreis ist also Summe aller Teile in der Stueckliste + eigener Preis
Public Sub summiere_Preise()
    Dim stupos As STUELI_Position
    Dim preis As Double
    Summe_EU = 0
    Summe_Non_EU = 0
    'Fa's mit verursacher_art <> 1 sind untergeordnete FA z.B zu einer Pumpenmontage
    'Deren Teile sind schon im Haupt-FA enthalten und dürfen daher hier nicht nochmals in die Preissumme einfließen
    'Sie sollen zum debuggen aber in der Struktur enthalten sein
    If pos_typ = "FA_komm" Then
        If verurs_art <> 1 Then
            Exit Sub
        End If
    End If
    For Each stupos In stueli
        'Debug.Print stupos.level, stupos.pos_typ, stupos.pos_nr, stupos.teile_daten.t_tg_nr
        'erst Preise der Stuecklisten-Kinder summieren
        stupos.summiere_Preise
        'Gesamtsumme ist Summe der Summen aller Kinder
        Summe_EU = Summe_EU + stupos.Summe_EU
        Summe_Non_EU = Summe_Non_EU + stupos.Summe_Non_EU
    Next
    'Eigenen Preis dazu
    Summe_EU = Summe_EU + preis_EU
    Summe_Non_EU = Summe_Non_EU + preis_Non_EU
End Sub
'Schreibt eine Stückliste und rekursiv deren Kinder
'in die Tabelle zur Dokumentation eines Kundenauftrages (reduzierter Datenumfang)
Public Sub writeSTU2Excel_KA_doku(row As Long)
    Dim stupos As STUELI_Position
    'Fa's mit verursacher_art <> 1 sind untergeordnete FA z.B zu einer Pumpenmontage
    'Deren Teile sind schon im Haupt-FA enthalten und sollen nicht in der Doku erscheinen
    If pos_typ = "FA_Komm" Then
        If verurs_art <> 1 Then
            Exit Sub
        End If
    End If
    'Pos ausgeben
    writePos2Excel_KA_doku row
    row = row + 1
    'Kinder ausgeben
    For Each stupos In stueli
        'row = row + 1
        'Kinder ausgeben
        stupos.writeSTU2Excel_KA_doku row
    Next
End Sub
'Schreibt eine Stückliste und rekursiv deren Kinder
'in die Tabelle zum Debuggen (voller Daten-Umfang)
Public Sub writeSTU2Excel_debug(row As Long)
    Dim stupos As STUELI_Position
    'Pos ausgeben
    writePos2Excel_debug row
    row = row + 1
    'Kinder ausgeben
    For Each stupos In stueli
        'row = row + 1
        'Kinder ausgeben
        stupos.writeSTU2Excel_debug row
    Next
End Sub
'Schreibt eine Stücklistenposition
'in die Tabelle zur Dokumentation eines Kundenauftrages (reduzierter Datenumfang)
Public Sub writePos2Excel_KA_doku(myrow As Long)
    Dim col%
    Dim ratio As Double
    Dim praeferenzteil As Boolean
    Dim msg$
    col = 0
    'col = col + 1: stu_sheet.Cells(myrow, col) = myrow - 6 'Laufende Nummer
    col = col + 1: stu_sheet.Cells(myrow, col) = level_formatiert(level)
    'col = col + 1: stu_sheet.Cells(myrow, col) = pos_typ
    'col = col + 1: stu_sheet.Cells(myrow, col) = id_stu
    'col = col + 1: stu_sheet.Cells(myrow, col) = pos_nr
    col = col + 1: stu_sheet.Cells(myrow, col) = teile_daten.t_tg_nr
    col = col + 1: stu_sheet.Cells(myrow, col) = teile_daten.bezeichnung
    col = col + 1: stu_sheet.Cells(myrow, col) = menge_ueb
    'col = col + 1
    'col = col + 1: stu_sheet.Cells(myrow, col) = myrow - 6 'Laufende Nummer
    If teile_daten.hat_Preis Then
        stu_sheet.Cells(myrow, col + 1) = teile_daten.Bestelldaten.kurzname
        If teile_daten.praeferenzkennung Then
            stu_sheet.Cells(myrow, col + 2) = preis_EU
        Else
            stu_sheet.Cells(myrow, col + 3) = preis_Non_EU
        End If
    End If
    col = col + 3
    If level = 0 Then
        msg = pos_nr & " " & teile_daten.t_tg_nr & " " & teile_daten.bezeichnung
        ColorCells stu_sheet, myrow, KA_doku_header_min_col, KA_doku_header_max_col, "grau_2"
        col = col + 1: stu_sheet.Cells(myrow, col) = Summe_EU
        col = col + 1: stu_sheet.Cells(myrow, col) = Summe_Non_EU
        If vk_rabatt <> 0 Then
            col = col + 1: stu_sheet.Cells(myrow, col) = vk_rabatt
            ratio = Summe_Non_EU / vk_rabatt / menge
            col = col + 1: stu_sheet.Cells(myrow, col) = ratio
            praeferenzteil = True
            If Me.teile_daten.ist_Kaufteil Then
                praeferenzteil = Not (Summe_Non_EU > 0)
            Else
                praeferenzteil = ratio < 0.4
            End If
            col = col + 1
            If Not praeferenzteil Then
                stu_sheet.Cells(myrow, col) = "n"
                ColorCells stu_sheet, myrow, KA_doku_header_min_col, KA_doku_header_max_col, "rot"
                msg = msg & "  --- kein PT"
            Else
                stu_sheet.Cells(myrow, col) = "j"
            End If
        End If
        Logger.log msg, level:=1
    End If
End Sub
'Schreibt eine Stücklistenposition
'in die Tabelle zum Debuggen (voller Daten-Umfang)
Public Sub writePos2Excel_debug(myrow As Long)
    Dim col%
    col = 0
    col = col + 1: imp_sheet.Cells(myrow, col) = level_formatiert(level)
    col = col + 1: imp_sheet.Cells(myrow, col) = pos_typ
    col = col + 1: imp_sheet.Cells(myrow, col) = id_stu
    col = col + 1
    If pos_typ = "FA_Komm" Or pos_typ = "FA_Serie" Then
        imp_sheet.Cells(myrow, col) = FA_Nr
    End If
    col = col + 1: imp_sheet.Cells(myrow, col) = id_pos
    col = col + 1: imp_sheet.Cells(myrow, col) = ueb_s_nr
    col = col + 1: imp_sheet.Cells(myrow, col) = ds
    col = col + 1: imp_sheet.Cells(myrow, col) = pos_nr
    col = col + 1: imp_sheet.Cells(myrow, col) = verurs_art
    col = col + 1: imp_sheet.Cells(myrow, col) = teile_daten.t_tg_nr
    col = col + 1: imp_sheet.Cells(myrow, col) = teile_daten.oa
    col = col + 1: imp_sheet.Cells(myrow, col) = teile_daten.bezeichnung
    col = col + 1: imp_sheet.Cells(myrow, col) = teile_daten.unipps_typ
    col = col + 1: imp_sheet.Cells(myrow, col) = teile_daten.besch_art
    col = col + 1: imp_sheet.Cells(myrow, col) = teile_daten.urspr_land
    col = col + 1: imp_sheet.Cells(myrow, col) = teile_daten.ausl_u_land
    col = col + 1: imp_sheet.Cells(myrow, col) = teile_daten.praeferenzkennung
    col = col + 1: imp_sheet.Cells(myrow, col) = menge
    col = col + 1: imp_sheet.Cells(myrow, col) = teile_daten.sme
    col = col + 1: imp_sheet.Cells(myrow, col) = teile_daten.faktlme_sme
    col = col + 1: imp_sheet.Cells(myrow, col) = teile_daten.lme
    If teile_daten.hat_Preis Then
        teile_daten.Bestelldaten.write2Excel_debug myrow, col
        col = teile_daten.Bestelldaten.last_col + 1
        imp_sheet.Cells(myrow, col) = menge_ueb
        col = col + 1: imp_sheet.Cells(myrow, col) = preis_EU
        col = col + 1: imp_sheet.Cells(myrow, col) = preis_Non_EU
    End If
    col = 33
    If level < 2 Then
        col = col + 1: imp_sheet.Cells(myrow, col) = Summe_EU
        col = col + 1: imp_sheet.Cells(myrow, col) = Summe_Non_EU
        If vk_preis <> 0 Then
            col = col + 1: imp_sheet.Cells(myrow, col) = vk_preis
            col = col + 1: imp_sheet.Cells(myrow, col) = Summe_Non_EU / vk_preis / menge
        End If
    End If
End Sub


================================================================================
vbclass: Teiledaten
================================================================================
Option Explicit
'Public exists As Boolean 'Die Objekte werden angelegt bevor in UNIPPS nach Ihnen gesucht wird: Wenn gefunden => exist = True
Public hat_stueli As Boolean
'Public teil_zu_pos As Teil 'Daten zum Teil auf der Position
Public t_tg_nr$
Public oa%
Public bezeichnung$
Public unipps_typ$
Public besch_art%
Public urspr_land%
Public ausl_u_land%
Public praeferenzkennung%
Public sme%
Public faktlme_sme As Double
Public lme%
Public ist_Kaufteil As Boolean
Public ist_Fremdfertigung As Boolean
Public ist_Eigenfertigung As Boolean
Public hat_Preis As Boolean
Public preis As Double
Public preis_EU As Double
Public preis_Non_EU As Double
Public Bestelldaten As Bestellung
Public Sub init(record As Fields)
    t_tg_nr = Trim(record("t_tg_nr"))
    'Debug.Print t_tg_nr
    oa = record("oa")
    besch_art = record("besch_art")
    unipps_typ = record("typ")
    urspr_land = record("urspr_land")
    ausl_u_land = record("ausl_u_land")
    praeferenzkennung = record("praeferenzkennung")
    sme = record("sme")
    faktlme_sme = record("faktlme_sme")
    lme = record("lme")
    Set Bestelldaten = New Bestellung
    'Weitere Eigenschaften berechnen
    ist_Kaufteil = besch_art = 1
    ist_Eigenfertigung = besch_art = 2
    ist_Fremdfertigung = besch_art = 4
    'ist_Beschaffungsteil = ist_Kaufteil Or ist_Fremdfertigung
    If ist_Kaufteil Or ist_Fremdfertigung Then
        Bestelldaten.init t_tg_nr
        hat_Preis = Bestelldaten.existiert
    End If
    Dim gefunden As Boolean
    Dim rs As Recordset
    gefunden = SQL_exec.hole_Teile_Bezeichnung(t_tg_nr, rs)
    If gefunden Then
        bezeichnung = rs.Fields("bezeichnung")
    End If
End Sub


================================================================================
vbclass: FA
================================================================================
Option Explicit
'Eigenschaften fuer alle Eintraege
Public pos_typ$
Public id_stu$ 'Id der Stückliste zu der die Position gehört
'Public t_tg_nr$ 'Teilenummer des Teils auf der Position
Public pos_nr$
Public unipps_typ$
Public menge As Double
Public teile_daten As Teiledaten 'Daten zum Teil auf der Position, bleibt hier leer
Public stueli As Collection 'VBA-Stueckliste dieser Position
'Besondere Eigenschaften fuer diesen Typ
Public FA_Nr$
Public verurs_art%
Public auftragsart%
Public Sub init(record As Fields)
    pos_typ = "FA_Komm"
    menge = 1 'bei FA Menge ignorieren
    Set stueli = New Collection
    Set teile_daten = New Teiledaten
    id_stu = record("id_stu")
    pos_nr = Trim(record("pos_nr"))
    unipps_typ = Trim(record("typ"))
    FA_Nr = record("id_fa")
    verurs_art = record("verurs_art")
    auftragsart = record("auftragsart")
End Sub
Public Sub init_serie(record As Fields)
    pos_typ = "FA_Serie"
    menge = 1 'bei FA Menge ignorieren
    Set stueli = New Collection
    Set teile_daten = New Teiledaten
    'id_stu = record("id_stu")
    id_stu = Trim(record("t_tg_nr"))
    pos_nr = Trim(record("pos_nr"))
    unipps_typ = Trim(record("typ"))
    FA_Nr = record("id_fa")
    verurs_art = record("verurs_art")
    auftragsart = record("auftragsart")
End Sub
'Analysiert die UNIPPS-Tabelle ASTUELIPOS
'Sucht die Positionen der obersten Ebene in dieser Tabelle und rekursiv deren Kinder
'Wenn in ASTUELIPOS keine Kinder mehr enthalten, wird "mit suche_Kinder_v_Serien_Teil" weiter gesucht
'ob es eine Teile-Stückliste zum letzten gefunden Kind gibt, was bei Serenteilen der Fall ist.
Public Sub hole_Kinder()
    Dim fa_rs As Recordset
    Dim rs_pos As Long
    Dim gefunden As Boolean
    Dim FA_Pos As FA_Pos
    'Hole die Positionen des FA's aus der Unipps-Tabelle ASTUELIPOS
    gefunden = SQL_exec.hole_Pos_zu_FA(FA_Nr, fa_rs)
    'Hier nur toplevel-KNoten berücksichtigen
    'd.h. alle die in ASTUELIPOS keine übergeordnete Stückliste haben: ueb_s_nr=0
    fa_rs.Filter = "ueb_s_nr = 0"
    'Daten ausgeben
    Do While Not fa_rs.EOF
        rs_pos = fa_rs.AbsolutePosition
        'Debug.Print "                            rs.pos", fa_rs.AbsolutePosition
        'Erzeuge eine FA-position aus dem Datensatz
        Set FA_Pos = New FA_Pos
        FA_Pos.init fa_rs
        'in Liste übernehmen
        stueli.Add FA_Pos
        'Rekursiv weiter in ASTUELIPOS suchen wenn Knoten Kinder hat (Feld ds=1)
        If FA_Pos.hat_Kinder Then
            'Bearbeite Kindknoten
            FA_Pos.hole_Kinder fa_rs, FA_Pos.id_pos
        Else
          'Pos hat keine weiteren Kinder im FA => merken fuer spaetere Suchläufe, wenn kein Kaufteil
           If Not FA_Pos.teile_daten.ist_Kaufteil Then
                teile_ohne_stu.Add FA_Pos
           End If
        End If
        'Auf Toplevel filtern und hinter alten Datensatz positionieren (Move ist relativ)
        fa_rs.Filter = "ueb_s_nr = 0"
        fa_rs.MoveFirst
        fa_rs.Move rs_pos
    Loop
End Sub


================================================================================
vbclass: Teil_in_STU
================================================================================
Option Explicit
'Eigenschaften fuer alle Eintraege
Public pos_typ$
Public id_stu$ 'Id der Stückliste zu der die Position gehört
Public t_tg_nr$ 'Teilenummer des Teils auf der KA-Position
Public pos_nr$
Public menge As Double
Public teile_daten As Teiledaten 'Daten zum Teil auf der Position
Public stueli As Collection 'VBA-Stueckliste dieser Position
Public Sub init(record As Fields)
    Dim rs As Recordset
    Dim gefunden As Boolean
    pos_typ = "Teil"
    Set stueli = New Collection
    id_stu = Trim(record("id_stu"))
    t_tg_nr = Trim(record("t_tg_nr"))
    pos_nr = Trim(record("pos_nr"))
    menge = record("menge")
    'Suche Teil zu dieser Pos
    gefunden = SQL_exec.suche_Daten_zum_Teil(t_tg_nr, rs)
    If gefunden Then
        Set teile_daten = New Teiledaten
        teile_daten.init rs.Fields
    Else
        Logger.user_info "Konnte kein Teil >>" & t_tg_nr & "<< finden.", level:=2
    End If
End Sub
Public Sub xxxerzeuge_Baum(vater_stueli_pos As STUELI_Position)
    Dim pos As Variant
    Dim kind_stueli_pos As STUELI_Position
    For Each pos In stueli
        Set kind_stueli_pos = New STUELI_Position
        kind_stueli_pos.init pos, vater_stueli_pos.level + 1, vater_stueli_pos.menge_ueb
        'In Baum.stueli uebernehmen
        vater_stueli_pos.stueli.Add kind_stueli_pos
        pos.erzeuge_Baum kind_stueli_pos
    Next
End Sub


================================================================================
vbclass: FA_Pos
================================================================================
Option Explicit
'Eigenschaften fuer alle Eintraege
Public pos_typ$
Public t_tg_nr$ 'Teilenummer des Teils auf der KA-Position
Public pos_nr$
Public menge As Double
Public teile_daten As Teiledaten 'Daten zum Teil auf der Position
Public stueli As Collection 'VBA-Stueckliste dieser Position
'Besondere Eigenschaften fuer diesen Typ
Public id_stu$
Public id_pos$
Public ueb_s_nr$
Public ds$
Public set_block$
Public unipps_typ$
Public ist_toplevel As Boolean
Public hat_Kinder As Boolean
Public Sub init(rs As Recordset)
    Dim teil_rs As Recordset
    Dim gefunden As Boolean
    pos_typ = "FA_Pos"
    Set stueli = New Collection
    id_stu = rs.Fields("id_stu")
    id_pos = rs.Fields("id_pos") 'in ASTUELIPOS zeigt ueb_s_nr auf die ident_nr2
    t_tg_nr = Trim(rs.Fields("t_tg_nr"))
    pos_nr = rs.Fields("pos_nr")
    unipps_typ = Trim(rs.Fields("typ"))
    ueb_s_nr = rs.Fields("ueb_s_nr")
    ds = rs.Fields("ds")
    set_block = rs.Fields("set_block")
    menge = rs.Fields("menge")
    'Suche Teil zu dieser Pos
    gefunden = SQL_exec.suche_Daten_zum_Teil(t_tg_nr, teil_rs)
    If gefunden Then
        Set teile_daten = New Teiledaten
        teile_daten.init teil_rs.Fields
    Else
        Logger.user_info "Konnte kein Teil >>" & t_tg_nr & "<< finden.", level:=2
    End If
    'Ist der Eintrag auf der höchsten Ebene des FA
    If ueb_s_nr = 0 Then
        ist_toplevel = True
    Else
        ist_toplevel = False
    End If
    'Hat der Eintrag Kinder in ASTUELIPOS
    'Einträge mit set_block=1 sind in der Unipps-Tabelle ASTUELIPOS eines FA schon aufgelöst,
    If set_block = 1 Then
        hat_Kinder = True
    Else
        hat_Kinder = False
    End If
End Sub
'Holt rekursiv untergeordnete Stücklistenelemente aus dem FA (Tabelle astuelipos)
Public Sub hole_Kinder(fa_rs As Recordset, vater_stuli_id%)
    Dim FA_Pos As FA_Pos
    Dim rs_pos As Long
    'Suche alle Kinder der vater_stuli_id
    fa_rs.Filter = "ueb_s_nr = '" & Str(vater_stuli_id) & "'"
    Do While Not fa_rs.EOF
        rs_pos = fa_rs.AbsolutePosition
        'aktuellen Datensatz aus fa_rs in Objekt wandeln
        Set FA_Pos = New FA_Pos
        FA_Pos.init fa_rs
        Debug.Print FA_Pos.pos_nr, FA_Pos.t_tg_nr, FA_Pos.ueb_s_nr
        'in Liste übernehmen
        stueli.Add FA_Pos
        '------------------ Suche Kinder
        If FA_Pos.hat_Kinder Then
           'Teile mit set_block=1 sind schon von UNIPPS aufgelöst => Kinder direkt in Tabelle ASTUELIPOS des FA suchen
            '!!! -----------   Rekursion: Bearbeite Kindknoten
            FA_Pos.hole_Kinder fa_rs, FA_Pos.id_pos
        Else
           'Für Teile mit set_block<>1
           'Pos hat keine weiteren Kinder im FA => merken fuer spaetere Suchläufe, wenn kein Kaufteil
           If Not FA_Pos.teile_daten.ist_Kaufteil Then
                teile_ohne_stu.Add FA_Pos
           End If
        End If
        'Filter zurücksetzen und hinter alten Datensatz positionieren (Move ist relativ)
        fa_rs.Filter = "ueb_s_nr = '" & Str(vater_stuli_id) & "'"
        fa_rs.MoveFirst
        fa_rs.Move rs_pos
    Loop
End Sub
'Holt rekursiv untergeordnete Stücklistenelemente aus dem FA (Tabelle astuelipos)
'Es wird vorrausgesetzt das die Datensätze in astuelipos in der korrekten Reihenfolge stehen,
'd.h. auf jeden Vaterknoten folgen zunaechst die Kinder und bei denen evtl die Kindeskinder bevor
'der nächste Vater der gleichen Ebene folgt
'Wenn in ASTUELIPOS keine Kinder mehr enthalten, wird "mit suche_Kinder_v_Serien_Teil" weiter gesucht
'ob es eine Teile-Stückliste zum letzten gefunden Kind gibt, was bei Serenteilen der Fall ist.
Public Sub xxxhole_Kinder(fa_rs As Recordset, vater_stuli_id%)
    Dim FA_Pos As FA_Pos
    Dim gefunden As Boolean
    '!!!! Beachte: Hier wird der selbe Recordset verwendet, wie in der aufrufenden Funktion mit der selben Positionierung
    '##########
    fa_rs.MoveNext 'gehe auf naechsten Datensatz
    Do While Not fa_rs.EOF
        'aktuellen Datensatz aus fa_rs in Objekt wandeln
        Set FA_Pos = New FA_Pos
        FA_Pos.init fa_rs
        'Debug.Print FA_Pos.pos_nr, FA_Pos.t_tg_nr
        'Gehört der Eintrag zur übergeordneten Stückliste => ausgeben; sonst rücksprung
        'Achtung auch hier verlassen wir uns auf die korrekte Reihenfolge in ASTUELIPOS
        If FA_Pos.ueb_s_nr = vater_stuli_id Then
            'in Liste übernehmen
            stueli.Add FA_Pos
            '------------------ Suche Kinder
            If FA_Pos.hat_Kinder Then
               'Teile mit ds=1 sind schon von UNIPPS aufgelöst => Kinder direkt in Tabelle ASTUELIPOS des FA suchen
                '!!! -----------   Rekursion: Bearbeite Kindknoten
                FA_Pos.hole_Kinder fa_rs, FA_Pos.id_pos
            Else
               'Für Teile mit ds<>1
               'Pos hat keine weiteren Kinder im FA => merken fuer spaetere Suchläufe, wenn kein Kaufteil
               If Not FA_Pos.teile_daten.ist_Kaufteil Then
                    teile_ohne_stu.Add FA_Pos
               End If
            End If
        Else
            'Der aktuelle Eintrag ist kein Kind des in der Tabelle ASTUELIPOS darüber stehenden Eintrags
            '=> Rücksprung in der Rekursion, also eine Ebene höher und dort recordzeiger um 1 zurücksetzen
            '######
            fa_rs.MovePrevious
            Exit Do
        End If
        'Hier erneut Endebedingung prüfen, da Recordzeiger verändert wurde
        If Not fa_rs.EOF Then
            fa_rs.MoveNext
        End If
    Loop
End Sub


================================================================================
vbmodule: Suche_Kinder
================================================================================
'Hier stehen Funktionen zum Suchen von Kindern (Elementen einer Stückliste)
'Die Funktionen werden von mehreren Klassen verwendet und wurden deshalb nicht als Klassenfunktionen realisiert.
Option Explicit
'Verwendet von Kundenauftrags_Position.hole_kinder, FA.hole_kinder, FA_Pos.hole_kinder
'Teil ist Kaufteil => Suche beendet
'Fremdfertigung => suche über STU
'Eigenfertigung => suche über Fa oder STU
Public Function suche_Kinder_v_Serien_Teil(teil As Variant) As Boolean
    Dim gefunden As Boolean
    Dim Variante%
    Variante = 2
    'Debug.Print teil.t_tg_nr
    'Kaufteil
    If teil.teile_daten.ist_Kaufteil Then
        If Not teil.teile_daten.hat_Preis Then
            Logger.user_info "Kaufteil ohne Preis gefunden " & teil.t_tg_nr, level:=2
        End If
        'keine weitere Suche
        gefunden = True
    'Fremdfertigung
    ElseIf teil.teile_daten.ist_Fremdfertigung Then
        'Suche nur über Teilestueckliste
        gefunden = suche_Kinder_in_Teile_Stu(teil)
    'Eigenfertigung
    ElseIf teil.teile_daten.ist_Eigenfertigung Then
        'Weitere Suche auf 2 Arten
        If Variante = 1 Then
            'Suche erst über FA, dann über Teilestueckliste
            gefunden = suche_Serien_FA(teil)
            If Not gefunden Then
                gefunden = suche_Kinder_in_Teile_Stu(teil)
            End If
        Else
            'Suche nur über Teilestueckliste
            gefunden = suche_Kinder_in_Teile_Stu(teil)
        End If
    'Unerwartete Beschaffungsart => Daten oder Programmfehler
    Else
 Logger.user_info "Unerwartete Daten bei Teil >>" & teil.t_tg_nr & "<< gefunden"                         & "Beschaffungsart ist " & teil.teile_daten.besch_art, level:=2
        gefunden = False
    End If
    suche_Kinder_v_Serien_Teil = gefunden
End Function
'Holt rekursiv untergeordnete Stücklistenelemente aus der Tabelle teil_stuelipos
Public Function suche_Kinder_in_Teile_Stu(teil As Variant) As Boolean
    Dim kinder_teil As Teil_in_STU
    Dim rs As Recordset
    Dim gefunden As Boolean
    'Gibt es eine Stückliste zum Teil
    gefunden = SQL_exec.suche_Stueli_zu_Teil(teil.t_tg_nr, rs)
    'Wenn Kinder gefunden
    Do While Not rs.EOF
        'aktuellen Datensatz in Objekt wandeln
        Set kinder_teil = New Teil_in_STU
        kinder_teil.init rs.Fields
        'in Stueck-Liste übernehmen
        teil.stueli.Add kinder_teil
        'merken als Teil noch ohne Kinder fuer weitere Suchläufe
        teile_ohne_stu.Add kinder_teil
        'Naechter Datensatz
        rs.MoveNext
    Loop
    suche_Kinder_in_Teile_Stu = gefunden
End Function
'Public Function suche_Serien_FA(t_tg_nr$, stueli As Collection) As Boolean
Public Function suche_Serien_FA(teil As Variant) As Boolean
    Dim myFA As FA
    Dim rs As Recordset
    Dim gefunden As Boolean
    'Gibt es einen Serien_FA zum Teil
    gefunden = SQL_exec.suche_FA_zu_Teil(teil.t_tg_nr, rs)
    If Not gefunden Then
        suche_Serien_FA = False
        Exit Function
    End If
    'Erzeuge Objekt fuer einen Serien FA
    Set myFA = New FA
    myFA.init_serie rs.Fields
    'in Stueck-Liste übernehmen
    teil.stueli.Add myFA
    'Kinder suchen
    myFA.hole_Kinder
    suche_Serien_FA = gefunden
End Function


================================================================================
vbclass: STU_Baum
================================================================================
'Die Klasse enthält die Stücklistenstruktur in verallgemeinerter Form
'Dies vereinfacht das Durchlaufen durch den Baum, das alle Elemente (fast) gleich behandelt werden können
'Die Elemente gehören zur Klasse STUELI_Position und enthalten alle zur Ausgabe bzw Berechnung nötigen Daten
'und zusätzlich die spezifischen Original-Elemente aus Kundenauftrag,Teil_in_STU usw
Option Explicit
Public stueli As Collection 'VBA-Stueckliste dieser Position
Public Sub init()
    Set stueli = New Collection
End Sub
'Summiere Preise für ein Teil
' aus der Summe der Kosten aller Teile in seiner Stueckliste
' und einem evtl zusätzlich vorhandenen eigenen Preis
Public Sub summiere_Preise()
    Dim stupos As STUELI_Position
    Application.StatusBar = "Berechne Preissummen"
    'Preis der Position ermitteln
    'Umrechnung mit Gesamtmenge und Einheiten
    For Each stupos In stueli
        stupos.berechne_Preis_der_Position
    Next
    'Preise summieren
    For Each stupos In stueli
        stupos.summiere_Preise
    Next
End Sub
'Schreibt den kompletten Baum
'in die Tabelle zum Debuggen (voller Daten-Umfang)
Public Sub write2Excel_KA_doku()
    Dim stupos As STUELI_Position
    Dim row As Long
    Application.StatusBar = "Ausgabe nach Kalkulation"
    stu_sheet.PageSetup.LeftHeader = "Kundenauftrag: " & stueli(1).id_stu
    stu_sheet.PageSetup.RightHeader = "&D"
    'Hauptüberschriften schreiben
    stu_sheet.Range("e2") = stueli(1).id_stu
    stu_sheet.Range("E3") = stueli(1).komm_nr
    row = 7
    For Each stupos In stueli
        stupos.writeSTU2Excel_KA_doku row
        'row = row + 1
    Next
    'Mittel-Spalte ohne Schattierung
    'DeColorColumn stu_sheet, KA_doku_header_med_col
End Sub
'Schreibt den kompletten Baum
'in die Tabelle zur Dokumentation eines Kundenauftrages (reduzierter Datenumfang)
Public Sub write2Excel_debug()
    Dim stupos As STUELI_Position
    Dim row As Long
    Application.StatusBar = "Ausgabe nach Import"
    row = 2
    For Each stupos In stueli
        'Pos ausgeben
        stupos.writeSTU2Excel_debug row
        'row = row + 1
    Next
End Sub
'Suche alle Kinder von typ_spez_pos (Knoten im typspezifischen Format)
'Wandelt die Kinder in typunabhängige Form unter Berücksichtigung der Ebene und der Gesamtmenge
'legt typunabhängige Form in non_type_pos.stueli ab
'non_type_pos ist Knoten im typunabhängigen Format (Klasse STUELI_Position)
Public Sub erzeuge_Baum(typ_spez_pos As Variant, non_type_pos As STUELI_Position, mit_FA As Boolean)
    Dim pos As Variant
    Dim kind_stueli_pos As STUELI_Position
    Dim Ignore, Skip_complete  As Boolean
    For Each pos In typ_spez_pos.stueli
        'Debug.Print non_type_pos.level, pos.pos_nr, pos.t_tg_nr
        Skip_complete = False
        Ignore = False
        If Not mit_FA Then
            If pos.pos_typ = "FA_Komm" Or pos.pos_typ = "FA_Serie" Then
                'Fa-Eintraege sollen ignoriert, also nicht in die Doku übernommen werden
                'Es werden jedoch die Kinder eine Ebene höher eingehängt
                Ignore = True
                If pos.pos_typ = "FA_Komm" And pos.verurs_art <> 1 Then
                    'Auftragsbezogene Fa's mit verursacher_art <> 1 sind untergeordnete FA z.B zu einer Pumpenmontage
                    'Deren Teile sind schon im Haupt-FA enthalten und sollen nicht in der Doku erscheinen
                    'Knoten und alle Kinder werden ignoriert => Weiter im For-Loop mit naechster Pos
                    Skip_complete = True
                End If
            End If
        End If
        If Not Skip_complete Then
            If Ignore Then
                'Rekursion: Kinder fuer neu gefundene pos bearbeiten
                'Der Eintrag erfolgt aber in die stueli von non_type_pos, der bereits übergeben wurde
                'Im Gegensatz dazu wird im ELSE-Zweig die Stueli des neu gewandelten Kind-Knotens kind_stueli_pos verwendet
                '=> der aktuelle Eintrag pos wird im Baum übergangen
                erzeuge_Baum pos, non_type_pos, mit_FA
            Else
                'typunabhängige Pos erzeugen
                Set kind_stueli_pos = New STUELI_Position
                kind_stueli_pos.init pos, non_type_pos.level + 1, non_type_pos.menge_ueb
                'In stueli von non_type_pos uebernehmen
                non_type_pos.stueli.Add kind_stueli_pos
                'Rekursion: Kinder fuer neu gefundene pos bearbeiten
                'Der Eintrag der Kinder erfolgt in die Stueli des neu gewandelten Kind-Knotens kind_stueli_pos
                erzeuge_Baum pos, kind_stueli_pos, mit_FA
            End If
        End If
    Next
End Sub


================================================================================
vbmodule: Tests
================================================================================
Dim fehler_sheet As Worksheet
Dim f_row As Long
Public Sub export()
'Export_Current_VB
Export_all_VB
End Sub
'Hier nur Funktionen zum Testen
Public Sub test_KA_Analyse()
    Dim ka_id$
    set_logger True
    ka_id = 144260 'Pumpe mit Änderung
    'ka_id = 144211 'Pumpe
    'KA_id = 131645 'Pumpe
    'KA_id = 142302 'Ersatz
    'ka_id = 142567 '2 Pumpen
    'hole_KA_Positionen_fuer_Preisblatt ka_id
    start_KA_Analyse ka_id
End Sub
Public Sub test_store_pdf()
    Dim ka_id$
    ka_id = 144211 'Pumpe
    store_pdf ka_id
End Sub
Public Sub test_hole_KA_Positionen_fuer_Preisblatt()
    Dim ka_id$
    ka_id = 142302 'Pumpe
    ka_id = 142567 '2 Pumpen
    hole_KA_Positionen_fuer_Preisblatt ka_id
End Sub
Public Sub test_hole_rabatt()
    Dim myrange As Range
    Dim kunde$
    Dim gefunden As Boolean
    Dim rs As Recordset
    set_globals
    kunde = "1120840"
    gefunden = SQL_exec.hole_Rabatt_zum_Kunden(kunde, rs)
    Set myrange = rs_debug_sheet.Range("A1")
    UNIPPS_dbr.recordset_2_sheet myrange, rs, True, True
End Sub
Public Sub test_Dauerlauf()
    Dim gefunden As Boolean
    Dim ka_rs As Recordset
    Dim ka_id$
    Dim rec_pos As Long, max_rec As Long
    Dim myKA As Kundenauftrag
    Dim my_dbr As DB_Reader
    set_logger True
    Set my_dbr = New_DB_Reader
    gefunden = hole_KA_aus_UNIPPS(my_dbr, ka_rs)
    rec_pos = 400
    max_rec = 450
    ka_rs.Move rec_pos
    Do While Not ka_rs.EOF And rec_pos < max_rec
        ka_id = ka_rs.Fields("KA_ID")
        Logger.log ka_id & " " & ka_rs.Fields("klassifiz")
        Debug.Print ka_id, rec_pos
        hole_KA_Positionen_fuer_Preisblatt ka_id
        start_KA_Analyse ka_id
        store_pdf ka_id, False
        ka_rs.MoveNext
        rec_pos = rec_pos + 1
    Loop
    Set Logger = Nothing
End Sub
Public Function hole_KA_aus_UNIPPS(my_dbr As DB_Reader, rs As Recordset)
    'Datenbankreader anlegen und Verbindung herstellen
    my_dbr.Open_Informix_Connection
    Dim sql$, sql_sub$
    Dim teile_kriterium$
    sql = "select first 500 ident_nr as ka_id, klassifiz  from auftragkopf order by erstanlage desc"
    sql = "select first 500 ident_nr as ka_id, klassifiz  from auftragkopf where klassifiz like '2_.%' order by erstanlage desc"
    'Oeffne recordset
    Set rs = my_dbr.hole_recordset(sql)
    'Fehlerhandling
    If my_dbr.Connection.Errors.Count <> 0 Then
        Debug.Print sql
        Debug.Print my_dbr.Connection.Errors(0).Description
        abbruchmeldung "UNIPPS-Daten konnten nicht gelesen werden."
    End If
    hole_KA_aus_UNIPPS = rs.RecordCount > 0
End Function
Public Sub STU_Vergleich()
    Dim gefunden As Boolean
    Dim hat_Stu As Boolean
    Dim hat_Fa As Boolean
    Dim t_tg_nr$
    Dim rs As Recordset
    Dim rs_teile As Recordset
    Dim rs_fa As Recordset
    Dim rs_stu As Recordset
    Dim besch_art%
    Dim teile_art$
    set_globals
    Set fehler_sheet = data_wb.Worksheets("Fehler")
    f_row = 2
    besch_art = 2
    teile_art = "egal"
    'teile_art = "teil"
    'teile_art = "tg"
    gefunden = hole_Teile_aus_UNIPPS(rs_teile, teile_art, besch_art)
    Do While Not rs_teile.EOF
        t_tg_nr = Trim(rs_teile.Fields("t_tg_nr"))
        If t_tg_nr <> "" Then
            'Suche Teil
            gefunden = SQL_exec.suche_Daten_zum_Teil(t_tg_nr, rs)
            If gefunden Then
                Set teile_daten = New Teiledaten
                teile_daten.init rs.Fields
                'Gibt es eine Stückliste zum Teil
                hat_Stu = SQL_exec.suche_Stueli_zu_Teil(t_tg_nr, rs_stu)
                'Gibt es einen Serien_FA zum Teil
                hat_Fa = SQL_exec.suche_FA_zu_Teil(t_tg_nr, rs_fa)
                Debug.Print teile_daten.oa, t_tg_nr, "Stu", hat_Stu, "FA", hat_Fa, teile_daten.besch_art, "Preis", teile_daten.hat_Preis
                fehler_sheet.Cells(f_row, 1) = t_tg_nr: fehler_sheet.Cells(f_row, 2) = teile_daten.besch_art: fehler_sheet.Cells(f_row, 3) = hat_Stu
                fehler_sheet.Cells(f_row, 4) = hat_Fa: fehler_sheet.Cells(f_row, 5) = teile_daten.hat_Preis
                If hat_Fa Then
                     fehler_sheet.Cells(f_row, 6) = rs_fa.Fields("id_fa")
                End If
                If hat_Stu And hat_Fa Then
                     Stueli_Vergleich t_tg_nr, rs_stu, rs_fa
                End If
                f_row = f_row + 1
            Else
                fehler_sheet.Cells(f_row, 1) = t_tg_nr: fehler_sheet.Cells(f_row, 2) = "Konnte keine Teil daten finden."
                f_row = f_row + 1
            End If
        End If
        rs_teile.MoveNext
    Loop
End Sub
Public Sub Stueli_Vergleich(t_tg_nr$, rs_stu As Recordset, rs_fa As Recordset)
    Dim stu_fa  As New Collection, stu_stu As New Collection
    Dim i%
    Dim FA_Nr$, msg$
    FA_Nr = rs_fa.Fields("id_fa")
    hole_FA_Stueli rs_fa, stu_fa
    hole_Stueli_zu_Teil rs_stu, stu_stu
    If stu_fa.Count <> stu_stu.Count Then
        msg = "Länge ungleich fuer Teil " & t_tg_nr & " FA " & FA_Nr
        Debug.Print msg
        fehler_sheet.Cells(f_row, 7) = "Länge der STU ungleich"
        f_row = f_row + 1
    Else
        For i = 1 To stu_fa.Count
            If stu_fa.Item(i).t_tg_nr <> stu_stu.Item(i).t_tg_nr Then
                msg = "Kinder t_tg_nr ungleich fuer Item " & i & " Vater-Teil " & t_tg_nr & " FA " & FA_Nr
                Debug.Print msg
                fehler_sheet.Cells(f_row, 7) = "Kinder t_tg_nr ungleich fuer Item " & i
                f_row = f_row + 1
            End If
            If stu_fa.Item(i).menge <> stu_stu.Item(i).menge Then
                msg = "menge ungleich fuer Item " & i & " Vater-Teil " & t_tg_nr & " FA " & FA_Nr
                Debug.Print msg
                fehler_sheet.Cells(f_row, 7) = "Menge ungleich fuer Item " & i
                f_row = f_row + 1
            End If
        Next
   End If
End Sub
Public Sub hole_FA_Stueli(rs As Recordset, stueli As Collection)
    Dim FA_Nr$
    Dim gefunden As Boolean
    'Hole die Positionen des FA's aus der Unipps-Tabelle ASTUELIPOS
    FA_Nr = rs.Fields("id_fa")
    gefunden = SQL_exec.hole_Pos_zu_FA(FA_Nr, rs)
    If Not gefunden Then
        fehler_sheet.Cells(f_row, 7) = "keine FA Daten gefunden"
        f_row = f_row + 1
        Exit Sub
    End If
    Do While Not rs.EOF
        'Erzeuge eine FA-position aus dem Datensatz
        Set FA_Pos = New FA_Pos
        FA_Pos.init rs
        'Hier nur toplevel-KNoten berücksichtigen
        'd.h. alle die in ASTUELIPOS keine übergeordnete Stückliste haben: ueb_s_nr=0
        If FA_Pos.ist_toplevel Then
            'in Liste übernehmen
            stueli.Add FA_Pos
        Else
            'In Serien FA sollten nur toplevel-KNoten sein.
            msg = "Unerwartete Datenstruktur in 'ASTUELIPOS'. Toplevelknoten mit Feld ueb_s_nr=0 erwartet."
            fehler_sheet.Cells(f_row, 6) = msg
        End If
        rs.MoveNext
    Loop
End Sub
Public Sub hole_Stueli_zu_Teil(rs As Recordset, stueli As Collection)
    Dim kinder_teil As Teil_in_STU
    Do While Not rs.EOF
        'aktuellen Datensatz in Objekt wandeln
        Set kinder_teil = New Teil_in_STU
        kinder_teil.init rs.Fields
        'in Stueck-Liste übernehmen
        stueli.Add kinder_teil
        rs.MoveNext
    Loop
End Sub
Public Function hole_Teile_aus_UNIPPS(rs As Recordset, teile_art$, besch_art%)
    Dim sql$, sql_sub$
    Dim teile_kriterium$
    Dim sql_exe As New SQL_Executor
    If teile_art = "egal" Then
        teile_kriterium = "<9"
    ElseIf teile_art = "teil" Then
        teile_kriterium = "=1"
    ElseIf teile_art = "tg" Then
        teile_kriterium = "=0"
    Else
        MsgBox "Ungültige Teileart " & teile_art
        End
    End If
 sql_where = "Where teil_uw.t_tg_nr not like ""E%"" " & "and teil_uw.t_tg_nr not like ""B%"" " & "and teil_uw.t_tg_nr not like ""T%"" "                & "and teil_uw.v_besch_art=" & besch_art & " and teil_uw.oa" & teile_kriterium & " AND teil_uw.uw=1"
    sql = "SELECT count(teil_uw.t_tg_nr) as n "
    sql_from = "FROM teil_uw  "
    sql = sql + sql_from + sql_where
    Set rs = sql_exe.hole_recordset(sql)
    MsgBox rs.Fields("n") & " Teile gefunden"
    hole_Teile_aus_UNIPPS = rs.Fields("n") > 0
 sql = "SELECT teil_uw.t_tg_nr, teil_uw.oa, " & "teil_uw.v_besch_art as besch_art, teil.typ, teil.urspr_land, teil.ausl_u_land, teil.praeferenzkennung, "        & "teil.sme, teil.faktlme_sme, teil.lme "
    sql_from = "FROM teil INNER JOIN teil_uw ON teil.ident_nr = teil_uw.t_tg_nr AND teil.art = teil_uw.oa "
    'sql_where = "Where teil.ident_nr in (" & sql_sub & "); "
    sql = sql + sql_from + sql_where
    'Abfrage ausführen und recordset zurück liefern
    Set rs = sql_exe.hole_recordset(sql)
    'MsgBox rs.RecordCount & " Teile gefunden"
    'hole_Teile_aus_UNIPPS = rs.RecordCount > 0
End Function


================================================================================
vbclass: Logger_cls
================================================================================
Option Explicit
Public batch_modus As Boolean
Private logfile As TextStream
Private fso As FileSystemObject
Public Sub init(batch_mod As Boolean)
    Dim fso As FileSystemObject
    Dim logfilename$
    batch_modus = batch_mod
    logfilename = ThisWorkbook.Path & "\logfile.txt"
    Set fso = New FileSystemObject
    Set logfile = fso.CreateTextFile(logfilename)
End Sub
'Ausgabe per Messagebox oder im Batchmode in Datei
Public Sub user_info(msg$, Optional level% = 0)
    If batch_modus Then
        logfile.WriteLine space(level) & msg
    Else
        logfile.WriteLine space(level) & msg
        MsgBox msg
    End If
End Sub
'Ausgabe in Datei (unabhängig vom batchmode)
Public Sub log(msg$, Optional level% = 0)
    logfile.WriteLine space(level) & msg
End Sub
Private Function space(level%) As String
    Dim i
    space = ""
    For i = 1 To level
        space = space + "   "
    Next i
End Function
Private Sub Class_Terminate()
   logfile.Close
   Set logfile = Nothing
   Set fso = Nothing
End Sub


================================================================================
vbmodule: csv_export
================================================================================
Public SQLiteConnection As New ADODB.Connection
Public Function get_csv_file(filename$) As TextStream
    Dim fso As FileSystemObject
    Dim csv_filename$
    csv_filename = ThisWorkbook.Path & "\csv\" & filename$ & ".csv"
    Set fso = New FileSystemObject
    If fso.FileExists(csv_filename) Then
        Set get_csv_file = fso.OpenTextFile(csv_filename, ForAppending)
    Else
        Set get_csv_file = fso.CreateTextFile(csv_filename)
    End If
End Function
'Oeffnen von Datenbanken
Public Sub Open_SQLite_Connection()
    Dim SQLiteConnection As New ADODB.Connection
    'Set SQLite_dbr = New_DB_Reader
    db_path = "V:\E-MAIL\Dr Etscheidt\Datengrab\personal.sqlite"
    db_path = "C:\Users\Etscheidt\Documents\Embarcadero\Studio\Projekte\Zoll\db\zoll.sqlite"
    Dim sAdoConnectString As String, sPfad As String
    sAdoConnectString = "Dsn=unipps;Driver={INFORMIX 3.30 32 BIT};"
    'sAdoConnectString = "Dsn=SQLite Datasource;Driver=SQLite3 ODBC Driverdb_path =
    sAdoConnectString = "Driver=SQLite ODBC Driver;Database=" & db_path
    sAdoConnectString = "Dsn=zoll"
    On Error GoTo Fehler
    SQLiteConnection.Open sAdoConnectString
Aufraeumen:
    On Error Resume Next
    Exit Sub
Fehler:
    'MsgBox "Fehler beim Oeffnen der Connection: " & Err.Description
    Application.StatusBar = "Fehler beim Oeffnen der Connection: " & Err.Description
    Debug.Print Err.Description
    Resume Aufraeumen
End Sub
Public Sub csv_out(rs As Recordset, filename$)
    Dim line$
    Dim i%
    Dim Field As Field
    If mit_csv_export Then
        Set csv_file = get_csv_file(filename)
        Do While Not rs.EOF
            line = ""
            For i = 0 To rs.Fields.Count - 2
                line = line & rs.Fields(i).Value & ";"
            Next
            line = line & rs.Fields(i).Value
            rs.MoveNext
            csv_file.WriteLine line
        Loop
        If rs.RecordCount > 0 Then
            rs.MoveFirst
        End If
    End If
End Sub
Public Sub sqlite_out(rs As Recordset, tablename$)
    Dim line$
    Dim i%
    Dim Field As Field
    Dim rs_out As Recordset
    Open_SQLite_Connection
    SQLite_dbr.hole_recordset ("select * from kunde_zuab")
    Do While Not rs_out.EOF
        rs_out.MoveNext
    Loop
    Do While Not rs.EOF
        line = ""
        For i = 0 To rs.Fields.Count - 2
            line = line & rs.Fields(i).Value & ";"
        Next
        line = line & rs.Fields(i).Value
        rs.MoveNext
        csv_file.WriteLine line
    Loop
    If rs.RecordCount > 0 Then
        rs.MoveFirst
    End If
End Sub


================================================================================
vbmodule: xxxweg
================================================================================
'Erzeugt Text-Datei mit allen nicht präferenz-berechtigten Teilen
Public Sub xxxstore_non_eu_parts(ka_id$)
    Dim fso As FileSystemObject
    Dim outfile As TextStream
    Dim pfad$, file_name$
    Dim myrow As Long
    Dim teilenr$, pfk$, itemname$
    Dim i%
    set_globals
    pfad = data_wb.Path 'PDF ins Verzeichnis der Excel-Mappe
    file_name = pfad & "\" & ka_id$ & "_nicht_berechtigt.txt"
    Set fso = New FileSystemObject
    Set outfile = fso.CreateTextFile(file_name)
    '2 Durchgänge für deutsche und englische Ausgabe
    For i = 1 To 2
        If i = 1 Then
            itemname = "- item: "
        Else
            itemname = "- Ident-Nr.: "
        End If
        myrow = 7
        teilenr = stu_sheet.Cells(myrow, 2)
        Do While teilenr <> ""
            pfk = stu_sheet.Cells(myrow, 12)
            If pfk = "n" Then
                outfile.WriteLine itemname & teilenr
            End If
            myrow = myrow + 1
            teilenr = stu_sheet.Cells(myrow, 2)
        Loop
        outfile.WriteLine
    Next
    outfile.Close
End Sub


<EndofFile>